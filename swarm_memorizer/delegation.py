"""Functionality for task delegation."""

from dataclasses import dataclass, field
from enum import Enum
from functools import cached_property
from pathlib import Path
from textwrap import indent
from typing import Generator, Self, Sequence

from langchain.schema import SystemMessage

from swarm_memorizer.blueprint import (
    Blueprint,
    OrchestratorBlueprint,
    Reasoning,
    is_bot,
    load_blueprints,
)
from swarm_memorizer.config import SWARM_COLOR, VERBOSE
from swarm_memorizer.id_generation import generate_id
from swarm_memorizer.query import query_and_extract_reasoning
from swarm_memorizer.schema import (
    NONE,
    REASONING_OUTPUT_INSTRUCTIONS,
    REASONING_PROCESS_OUTPUT_INSTRUCTIONS,
    BlueprintId,
    Concept,
    DelegationSuccessful,
    DelegatorId,
    IdGenerator,
    ReasoningGenerationNotes,
)
from swarm_memorizer.task import Executor, Task
from swarm_memorizer.task_data import TaskData, search_task_records
from swarm_memorizer.toolkit.models import PRECISE_MODEL, format_messages, query_model
from swarm_memorizer.toolkit.text import (
    ExtractionError,
    dedent_and_strip,
    extract_blocks,
)
from swarm_memorizer.toolkit.yaml_tools import DEFAULT_YAML


class DelegatorReasoningGenerationNotes(Enum):
    """Notes for delegator reasoning generation."""

    OVERVIEW = ReasoningGenerationNotes.OVERVIEW.value.format(
        role=Concept.DELEGATOR.value
    )
    INFORMATION_RESTRICTIONS = (
        ReasoningGenerationNotes.INFORMATION_RESTRICTIONS.value.format(
            role=Concept.DELEGATOR.value,
            INFORMATION_SECTIONS=Concept.DELEGATOR_INFORMATION_SECTIONS.value,
        )
    )
    TERM_REFERENCES = ReasoningGenerationNotes.TERM_REFERENCES.value.format(
        role=Concept.DELEGATOR.value,
        example_section_1="TASK INFORMATION",
        example_section_2="SUCCESS RATE",
    )
    STEPS_RESTRICTIONS = ReasoningGenerationNotes.STEPS_RESTRICTIONS.value
    PROCEDURAL_SCRIPTING = ReasoningGenerationNotes.PROCEDURAL_SCRIPTING.value.format(
        role=Concept.DELEGATOR.value
    )


EXECUTOR_SELECTION_CONCEPTS = f"""
These are the concepts you should be familiar with:
- TASK: a task that must be done. Tasks do _not_ have strict deadlines, unless otherwise noted.
- {Concept.CONTEXT.value}: the context in which the TASK is being executed—provides background information that is relevant to the TASK, but not strictly required for its execution.
- {Concept.EXECUTOR.value}: an agent that is responsible for executing a task.
- TASK PERFORMANCE: the performance of an executor on tasks similar to the TASK, which is measured by the following metrics:
  - SUCCESS RATE: the proportion of similar tasks that the executor has successfully completed.
  - COMPLETION TIME: the average time in seconds it takes for the executor to complete a similar task.
- NEW {Concept.EXECUTOR.value}: an executor where there isn't enough history to determine its performance on the TASK. However, _all_ {Concept.EXECUTOR.value} candidates under consideration have done at least one similar task successfully.
- {Concept.ARTIFACT.value}: some information at a location that is relevant to the TASK, typically provided as input to the {Concept.EXECUTOR.value} for the TASK, and generated by them in turn as outputs.
""".strip()


def generate_executor_selection_reasoning() -> str:
    """Generate reasoning for selecting an executor."""
    context = """
    ## MISSION:
    You are the instructor for an AI task delegation agent. Your purpose is to provide a reasoning structure for the delegator to think through how to select an appropriate executor for a subtask.

    ## CONCEPTS:
    {concepts}
    
    ## DELEGATOR INFORMATION SECTIONS:
    The delegator has access to several sections of information that is relevant to its decisionmaking.
    - TASK INFORMATION: contains a brief description of information about the TASK. This will always include information the TASK requirement itself, but _may_ also contain contextual information for why the task is being executed.
    - {EXECUTOR} CANDIDATES: a list of executors that can be selected for the task. Each entry for an executor candidate has the following information:
        - DESCRIPTION: a brief description of the executor candidate's capabilities, as well as what it cannot do. This is what the candidate can _theoretically_ do, as opposed to its actual performance.
        - NEW STATUS: whether an executor candidate is a NEW {EXECUTOR} or not.
        - TASK PERFORMANCE: as defined above, including SUCCESS RATE and COMPLETION TIME. This information is only available for non-NEW {EXECUTOR} candidates.
    - EXECUTOR MEMORY: the memory the delegator has of previous interactions with some {EXECUTOR}s on a similar task. These executors may or may not appear in the current list of {EXECUTOR} candidates.
    """
    context = dedent_and_strip(context).format(
        concepts=EXECUTOR_SELECTION_CONCEPTS,
        EXECUTOR=Concept.EXECUTOR.value,
    )
    request = """
    ## REQUEST FOR YOU:
    {OVERVIEW}
    - {INFORMATION_RESTRICTIONS}
    - {TERM_REFERENCES}
    - As an initial part of the reasoning, the delegator must figure out whether to lean towards exploration using NEW {EXECUTOR} candidates or exploitation using non-NEW {EXECUTOR} candidates. This of course depends on how good the non-NEW {EXECUTOR} candidates are.
    - The {DELEGATOR} does _not_ have to select _any_ of the candidates, if it deems none of them to be suitable for the task.
    - The {DELEGATOR} must understand the difference between the actual requirements of the TASK and the {CONTEXT} that the TASK is being executed in. {EXECUTOR} candidates only need to be able to fulfill the actual requirements of the TASK itself—the {CONTEXT} is for background information only.
    - {STEPS_RESTRICTIONS}
    - {PROCEDURAL_SCRIPTING}
    - The final decision of which {EXECUTOR} CANDIDATE to use (or to not use any at all) must be done on the last step only, after considering all the information available from the previous steps.

    {output_instructions}
    """
    request = (
        dedent_and_strip(request)
        .replace("{output_instructions}", REASONING_PROCESS_OUTPUT_INSTRUCTIONS)
        .format(
            DELEGATOR=Concept.DELEGATOR.value,
            OVERVIEW=DelegatorReasoningGenerationNotes.OVERVIEW.value,
            INFORMATION_RESTRICTIONS=DelegatorReasoningGenerationNotes.INFORMATION_RESTRICTIONS.value,
            TERM_REFERENCES=DelegatorReasoningGenerationNotes.TERM_REFERENCES.value,
            EXECUTOR=Concept.EXECUTOR.value,
            CONTEXT=Concept.CONTEXT.value,
            STEPS_RESTRICTIONS=DelegatorReasoningGenerationNotes.STEPS_RESTRICTIONS.value,
            PROCEDURAL_SCRIPTING=DelegatorReasoningGenerationNotes.PROCEDURAL_SCRIPTING.value,
        )
    )
    messages = [
        SystemMessage(content=context),
        SystemMessage(content=request),
    ]
    return query_and_extract_reasoning(
        messages,
        preamble="Generating reasoning for executor selection...\n"
        f"{format_messages(messages)}",
        printout=VERBOSE,
    )


@dataclass
class BlueprintSearchResult:
    """Result of a blueprint search."""

    blueprint: Blueprint
    is_new: bool
    task_subpool: list[TaskData] = field(default_factory=list)

    @property
    def success_rate(self) -> float | None:
        """Success rate of the blueprint given the tasks."""
        if not self.task_subpool or self.is_new:
            return None

        raise NotImplementedError("TODO")
        # success_rate = (
        #     num_success := sum(task.success(blueprint_id=blueprint.id) for task in self.task_pool)
        # ) / (num_similar_tasks := len(self.task_pool))

    @property
    def task_subpool_size(self) -> int:
        """Number of similar tasks."""
        return len(self.task_subpool)

    @property
    def completion_time(self) -> float | None:
        """Average completion time of the blueprint given the tasks."""
        if not self.task_subpool or self.is_new:
            return None
        raise NotImplementedError("TODO")
        # completion_time = (
        #     sum(task.completion_time for task in self.task_pool)
        #     / task_pool_size
        # )

    @property
    def scaled_completion_time(self) -> float | None:
        """Scaled completion time of the blueprint given the tasks."""
        if not self.task_subpool or self.is_new:
            return None
        raise NotImplementedError("TODO")
        # scaled_completion_time = completion_time / (1 + completion_time)

    @property
    def rating(self) -> float | None:
        """Rating of the blueprint given the tasks."""
        if not self.task_subpool or self.is_new:
            return None

        if self.success_rate == 0:
            return 0

        raise NotImplementedError("TODO")
        # rating = success_rate / (1 + scaled_completion_time)

    def __str__(self) -> str:
        """String representation of the blueprint search result."""
        printout = """
        ID: {blueprint_id}
        - DESCRIPTION: |-
        {description}
        - NEW STATUS: {status}
        - TASK PERFORMANCE:
            - SUCCESS RATE: {success_rate}
            - COMPLETION TIME: {completion_time}
        """
        description = indent(str(self.blueprint.description), "    ")
        return dedent_and_strip(printout).format(
            blueprint_id=self.blueprint.id,
            description=description,
            status="NEW" if self.is_new else "NOT NEW",
            success_rate=self.success_rate if self.success_rate is not None else "N/A",
            completion_time=(
                self.completion_time if self.completion_time is not None else "N/A"
            ),
        )


def rerank_tasks(task_info: str, similar_tasks: list[TaskData]) -> list[TaskData]:
    """Rerank similar tasks based on task similarity."""
    raise NotImplementedError("TODO")


def is_new(
    blueprint: Blueprint, similar_task_data: Sequence[TaskData], task_history_limit: int
) -> bool:
    """Check if a blueprint is new."""
    if not similar_task_data:
        return True

    blueprint_ids = [
        task_data.executor_blueprint_ids for task_data in similar_task_data
    ]
    num_tasks_containing_blueprint = sum(
        blueprint.id in task_execution_blueprint_ids
        for task_execution_blueprint_ids in blueprint_ids
    )
    return num_tasks_containing_blueprint <= task_history_limit


@dataclass(frozen=True)
class Delegator:
    """Delegates tasks to executors, creating new ones if needed."""

    executors_dir: Path
    task_records_dir: Path
    task_search_rerank_threshold: int
    id_generator: IdGenerator

    @cached_property
    def id(self) -> DelegatorId:
        """Id of the delegator."""
        return generate_id(DelegatorId, self.id_generator)

    def search_blueprints(
        self,
        task_info: str,
        rank_limit: int | None = None,
        task_history_limit: int = 10,
    ) -> list[BlueprintSearchResult]:
        """Search for blueprints of executors that can handle a task."""
        similar_tasks = search_task_records(task_info, self.task_records_dir)
        if len(similar_tasks) > self.task_search_rerank_threshold:
            similar_tasks = rerank_tasks(task_info, similar_tasks)
        past_blueprint_ids = [
            task_data.last_executor_blueprint_id for task_data in similar_tasks
        ]

        def check_blueprint(blueprint: Blueprint) -> tuple[bool, bool]:
            """Check if a blueprint is a candidate for the task."""
            assert blueprint.rank is not None
            new = is_new(
                blueprint, similar_tasks, task_history_limit=task_history_limit
            )
            if (
                blueprint.id not in past_blueprint_ids
                and not is_bot(blueprint)
                or (rank_limit is not None and blueprint.rank > rank_limit)
            ):
                return False, new

            if new:
                return True, new

            raise NotImplementedError("TODO")
            # > TODO: filter by minimum success rate, given large enough task history > task success is restricted to similar tasks that executor dealt with before
            # > need to be able to exclude bots as normal based on success rate—they might not be suitable for the task

        blueprint_candidacy = [
            (blueprint, *check_blueprint(blueprint))
            for blueprint in load_blueprints(self.executors_dir)
        ]
        candidate_blueprints = [
            (blueprint, new)
            for blueprint, is_candidate, new in blueprint_candidacy
            if is_candidate
        ]
        if not candidate_blueprints:
            return []
        search_results: list[BlueprintSearchResult] = []
        for blueprint, new in candidate_blueprints:
            candidate_similar_tasks = [
                task
                for task in similar_tasks
                if task.last_executor_blueprint_id == blueprint.id
            ]
            assert candidate_similar_tasks or is_bot(
                blueprint
            ), f"Blueprint search: no similar tasks found for non-bot blueprint:\n\nBlueprint:\n{blueprint}\n\nTask:\n{task_info}"
            search_results.append(
                BlueprintSearchResult(blueprint, new, candidate_similar_tasks)
            )
        return search_results

    def choose_next_executor(
        self,
        candidates: list[BlueprintSearchResult],
        task: Task,
        executor_selection_reasoning: str,
        executor_memory: str | None,
    ) -> BlueprintSearchResult | None:
        """Evaluate candidates for a task."""
        context = """
        ## MISSION:
        You are a delegator for a task that must be completed. Your purpose is to select an appropriate executor for the task based on a particular reasoning process.

        ## CONCEPTS:
        These are the concepts you must be aware of in order to perform delegation:
        {concepts}

        ## TASK INFORMATION:
        Here is the information about the TASK:
        ```start_of_task_info
        {task_information}
        ```end_of_task_info

        Here is information about the CONTEXT for the task, if available:
        ```start_of_context_info
        {context_information}
        ```end_of_context_info

        ## {EXECUTOR} CANDIDATES:
        Here are the {EXECUTOR} candidates that can be selected for the task.
        ```start_of_executor_candidates
        {executor_candidates}
        ```end_of_executor_candidates

        ## {EXECUTOR} MEMORY:
        Here are some memories of previous interactions with {EXECUTOR}s on a similar task that may (or may not) be relevant to the current task:
        ```start_of_executor_memory
        {executor_memory}
        ```end_of_executor_memory
        """
        executor_candidates_printout = "\n".join(
            str(candidate) for candidate in candidates
        )
        context = dedent_and_strip(context).format(
            concepts=EXECUTOR_SELECTION_CONCEPTS,
            EXECUTOR=Concept.EXECUTOR.value,
            task_information=task.information_with_artifacts,
            context_information=task.context,
            executor_candidates=executor_candidates_printout,
            executor_memory=executor_memory,
        )
        request = """
        ## REQUEST FOR YOU:
        Use the following reasoning process to select the best {EXECUTOR} for the task:
        ```start_of_reasoning_process
        {reasoning_process}
        
        Remember that the task cannot be split among multiple {EXECUTOR}s; if no single {EXECUTOR} can complete the task, then the task must remain undelegated. However, some parts of the TASK INFORMATION may be context—the {EXECUTOR} doesn't need to be able to execute any part of the work outside of the primary task.
        ```end_of_reasoning_process

        {reasoning_output_instructions}

        After this block, you must output your final choice of {EXECUTOR} in this format:
        ```start_of_executor_choice
        comment: |-
          {{comment}}
        executor_id: |-
          {{executor_id}}
        ```end_of_executor_choice
        {{executor_id}} can be `{NONE}` if you decide that no {EXECUTOR} is capable of performing the entire task end-to-end.
        Any additional comments or thoughts can be added before or after the output blocks.
        """
        request = (
            dedent_and_strip(request)
            .replace("{reasoning_output_instructions}", REASONING_OUTPUT_INSTRUCTIONS)
            .format(
                EXECUTOR=Concept.EXECUTOR.value,
                NONE=NONE,
                reasoning_process=executor_selection_reasoning,
            )
        )
        messages = [
            SystemMessage(content=context),
            SystemMessage(content=request),
        ]
        result = query_model(
            model=PRECISE_MODEL,
            messages=messages,
            preamble=f"Selecting executor for task...\n{format_messages(messages)}",
            printout=VERBOSE,
            color=SWARM_COLOR,
        )
        if not (extracted_result := extract_blocks(result, "start_of_executor_choice")):
            raise ExtractionError("Could not extract executor choice from the result.")
        extracted_result = DEFAULT_YAML.load(extracted_result[0])
        blueprint_id = BlueprintId(
            extracted_result["executor_id"]
        )  # in the prompt, it's "executor_id"
        if str(blueprint_id) == NONE:
            return
        try:
            chosen_candidate = next(
                candidate
                for candidate in candidates
                if candidate.blueprint.id == blueprint_id
            )
        except StopIteration as error:
            raise ExtractionError(
                f"Executor choice: could not find blueprint with id {blueprint_id} in candidates:\n{candidates}"
            ) from error
        return chosen_candidate

    def copy(self) -> Self:
        """Create a copy of the delegator."""
        return self.__class__(
            executors_dir=self.executors_dir,
            task_records_dir=self.task_records_dir,
            task_search_rerank_threshold=self.task_search_rerank_threshold,
            id_generator=self.id_generator,
        )

    def create_orchestrator(
        self, task: Task, recent_events_size: int, auto_await: bool
    ) -> Executor:
        """Factory for creating a new executor for a task."""
        # pylint: disable=import-outside-toplevel
        from swarm_memorizer.orchestration import Orchestrator

        assert task.rank_limit is None or task.rank_limit > 0
        blueprint = OrchestratorBlueprint(
            name=f"orchestrator_{task.id}",
            description=None,
            rank=None,
            reasoning=Reasoning(),
            knowledge=None,
            recent_events_size=recent_events_size,
            auto_wait=auto_await,
            id=generate_id(BlueprintId, self.id_generator),
        )
        return Orchestrator(
            blueprint=blueprint,
            task=task,
            files_parent_dir=self.executors_dir,
            delegator=self.copy(),
        )

    def find_top_candidates(
        self,
        candidates: Sequence[BlueprintSearchResult],
        max_candidates: int,
    ) -> list[BlueprintSearchResult]:
        """Find the top candidates."""
        if len(candidates) <= max_candidates:
            return list(candidates)

        raise NotImplementedError("TODO")
        # TODO: separate list for new vs old executors; take max 1/3 from new, max 2/3 from old, fill rest with remaining list
        # candidates = sorted(
        #     candidates,
        #     key=lambda result: float("inf")
        #     if (rating := result.rating is None)
        #     else rating,
        #     reverse=True,
        # )

    def reorder_candidate_list(
        self,
        candidates: list[BlueprintSearchResult],
        task: Task,
        executor_selection_reasoning: str,
        executor_memory: str | None,
    ) -> Generator[BlueprintSearchResult, None, None]:
        """Reorder the candidate list."""
        chosen: set[BlueprintId] = set()
        while len(chosen) < len(candidates):
            available_candidates = [
                candidate
                for candidate in candidates
                if candidate.blueprint.id not in chosen
            ]
            if not (
                next_candidate := self.choose_next_executor(
                    available_candidates,
                    task,
                    executor_selection_reasoning,
                    executor_memory=executor_memory,
                )
            ):
                return

            chosen.add(next_candidate.blueprint.id)
            yield next_candidate

    def delegate(
        self,
        task: Task,
        executor_selection_reasoning: str,
        executor_memory: str | None,
        max_candidates: int = 10,
    ) -> DelegationSuccessful:
        """Find an executor to delegate the task to."""
        # pylint: disable=import-outside-toplevel
        from swarm_memorizer.loading import load_executor

        candidates = self.search_blueprints(
            task.data.initial_information, task.rank_limit
        )
        if not candidates:
            return DelegationSuccessful(False)

        candidates = self.find_top_candidates(candidates, max_candidates)
        for candidate in self.reorder_candidate_list(
            candidates,
            task,
            executor_selection_reasoning,
            executor_memory=executor_memory,
        ):
            candidate = load_executor(
                candidate.blueprint,
                task,
                self.executors_dir / candidate.blueprint.id,
                delegator=self.copy(),
            )
            task.change_executor(candidate)
            if candidate.accepts(task):
                task.rank_limit = candidate.rank
                return DelegationSuccessful(True)

            task.add_current_execution_outcome_to_history()
        return DelegationSuccessful(False)

    def assign_executor(
        self,
        task: Task,
        recent_events_size: int,
        auto_await: bool,
        executor_selection_reasoning: str,
        executor_memory: str | None,
    ) -> None:
        """Assign an existing or new executor to a task."""
        delegation_successful = self.delegate(
            task, executor_selection_reasoning, executor_memory=executor_memory
        )
        # blueprints represent known capabilities; so, failure means we must create a new executor
        if not delegation_successful:
            task.change_executor(
                self.create_orchestrator(task, recent_events_size, auto_await)
            )