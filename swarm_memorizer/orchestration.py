"""Orchestrator agent."""

import asyncio
from dataclasses import dataclass, field
from enum import Enum
from functools import cached_property
from itertools import chain
from pathlib import Path
from textwrap import indent
from typing import Any, Iterable, Self, Sequence

from langchain.schema import SystemMessage, AIMessage
from ruamel.yaml import YAMLError, YAML
from swarm_memorizer.artifact import Artifact
from swarm_memorizer.blueprint import Knowledge, OrchestratorBlueprint, Reasoning

from swarm_memorizer.config import SWARM_COLOR, VERBOSE
from swarm_memorizer.acceptance import decide_acceptance
from swarm_memorizer.delegation import Delegator, generate_executor_selection_reasoning
from swarm_memorizer.description import generate_agent_description
from swarm_memorizer.event import (
    Event,
    EventLog,
    Message,
    PausedSubtaskDiscussion,
    StartedSubtaskDiscussion,
    SubtaskIdentification,
    TaskDescriptionUpdate,
    TaskStatusChange,
    Thought,
)
from swarm_memorizer.execution import execute_and_validate
from swarm_memorizer.id_generation import generate_id
from swarm_memorizer.query import query_and_extract_reasoning
from swarm_memorizer.schema import (
    REASONING_OUTPUT_INSTRUCTIONS,
    REASONING_PROCESS_OUTPUT_INSTRUCTIONS,
    Concept,
    EventId,
    IdGenerator,
    PauseExecution,
    ReasoningGenerationNotes,
    Role,
    RuntimeId,
    TaskWorkStatus,
    ActionName,
    WorkValidationResult,
)
from swarm_memorizer.task import (
    ExecutionReport,
    Task,
    TaskList,
    change_status,
    create_task_message,
    send_subtask_message,
)
from swarm_memorizer.task_data import TaskData, TaskDescription
from swarm_memorizer.toolkit.files import make_if_not_exist
from swarm_memorizer.toolkit.models import (
    PRECISE_MODEL,
    format_messages,
    query_model,
    SUPER_CREATIVE_MODEL,
)
from swarm_memorizer.toolkit.text import (
    ExtractionError,
    dedent_and_strip,
    extract_blocks,
)
from swarm_memorizer.toolkit.yaml_tools import DEFAULT_YAML, format_as_yaml_str


ORCHESTRATOR_STATE_CONCEPTS = f"""
- {Concept.ARTIFACT.value}: some information at a location that is relevant to the {Concept.MAIN_TASK.value}, typically provided as input to the {Concept.EXECUTOR.value} for the TASK, and generated by them in turn as outputs. The {Concept.MAIN_TASK.value} can only be complete when there is a set of {Concept.ARTIFACT.value}s that represent its final output.
""".strip()


@dataclass
class CoreState:
    """Core runtime state of an orchestrator."""

    id: RuntimeId
    knowledge: str
    main_task: Task
    subtasks: TaskList
    template: str

    def __str__(self) -> str:
        """String representation of the core state."""
        completed_subtasks = str(
            self.subtasks.filter_by_status(TaskWorkStatus.COMPLETED)
        )
        cancelled_subtasks = str(
            self.subtasks.filter_by_status(TaskWorkStatus.CANCELLED)
        )
        in_validation_subtasks = str(
            self.subtasks.filter_by_status(TaskWorkStatus.IN_VALIDATION)
        )
        delegated_subtasks = str(
            self.subtasks.filter_by_status(TaskWorkStatus.IN_PROGRESS)
        )
        blocked_subtasks = str(self.subtasks.filter_by_status(TaskWorkStatus.BLOCKED))
        return dedent_and_strip(self.template).format(
            knowledge=self.knowledge,
            orchestrator_state_concepts=ORCHESTRATOR_STATE_CONCEPTS,
            task_specification=str(self.main_task),
            completed_subtasks=completed_subtasks,
            cancelled_subtasks=cancelled_subtasks,
            in_validation_subtasks=in_validation_subtasks,
            delegated_subtasks=delegated_subtasks,
            blocked_subtasks=blocked_subtasks,
        )


ORCHESTRATOR_CONCEPTS = """
- {ORCHESTRATOR}: the agent that is responsible for managing the execution of a main task and managing the statuses of its subtasks, while communicating with the task's owner to gather required information for the task. The orchestrator must communicate with both the task owner and subtask executors to complete the main task as efficiently as possible.
- {MAIN_TASK}: the main task that the orchestrator is responsible for managing, which it does by identifying subtasks and providing support for specialized executor agents for the subtasks.
- {MAIN_TASK_OWNER}: the one who requested the main task to be done. The orchestrator must communicate with the task owner to gather background information required to complete the main task.
- {SUBTASK}: a task that must be executed in order to complete the main task. The orchestrator does NOT execute subtasks itself; instead, it facilitates the resolution of subtasks by making high-level decisions regarding each subtask in the context of the overall task and providing support for the subtask executors.
- SUBTASK STATUS: the status of subtasks that have already been identified. The status of a subtask can be one of the following:
  - {BLOCKED}: the subtask is blocked by some issue, and execution cannot continue until the issue is resolved, typically by discussing the blocker and/or identifying a new subtask to resolve the blocker.
  - {IN_PROGRESS}: the subtask is currently being executed by a subtask executor.
  - {IN_VALIDATION}: the subtask has been reported as completed by its executor, but is still being validated by a validator. Validation happens automatically and does not require or action from the orchestrator.
  - {COMPLETED}: the subtask has been validated as complete by a validator. Completed subtasks provide a record of overall successful progress for the main task.
  - {CANCELLED}: the subtask has been cancelled for various reason and will not be done.
- {SUBTASK_EXECUTOR}: an agent that is responsible for executing a {SUBTASK}. {SUBTASK_EXECUTOR}s specialize in executing certain types of tasks; whenever a subtask is identified, an executor is automatically assigned to it without any action required from the orchestrator.
- {ARTIFACT}: some information at a location that is relevant to the {MAIN_TASK} and/or its {SUBTASK}s. {ARTIFACT}s have both `location` and `description` parameters. There are two sources of {ARTIFACT}s:
  - {MAIN_TASK_OWNER}: the task owner may provide {ARTIFACT}s to the {ORCHESTRATOR} when initiating a task, or in later discussion with the {ORCHESTRATOR}.
  - {SUBTASK} Completion: when a {SUBTASK} is marked as {COMPLETED}, any {ARTIFACT}s generated by its completion is listed under the {SUBTASK}'s entry.
""".strip().format(
    **{
        "ORCHESTRATOR": Concept.ORCHESTRATOR.value,
        "MAIN_TASK": Concept.MAIN_TASK.value,
        "MAIN_TASK_OWNER": Concept.MAIN_TASK_OWNER.value,
        "SUBTASK": Concept.SUBTASK.value,
        "BLOCKED": TaskWorkStatus.BLOCKED.value,
        "IN_PROGRESS": TaskWorkStatus.IN_PROGRESS.value,
        "IN_VALIDATION": TaskWorkStatus.IN_VALIDATION.value,
        "COMPLETED": TaskWorkStatus.COMPLETED.value,
        "CANCELLED": TaskWorkStatus.CANCELLED.value,
        "SUBTASK_EXECUTOR": Concept.EXECUTOR.value,
        "ARTIFACT": Concept.ARTIFACT.value,
    }
)


class ActionModeName(Enum):
    """States of an action."""

    DEFAULT = "DEFAULT"
    SUBTASK_DISCUSSION = "SUBTASK DISCUSSION"


ORCHESTRATOR_INSTRUCTOR_MISSION = """
You are the instructor for an AI task orchestration agent. Your purpose is to provide a nested reasoning structure for the agent to think through what it must do next.""".strip()

MODULAR_SUBTASK_IDENTIFICATION = """
"Modular Subtask Identification" (MSI) is a philosophy for identifying a required subtask from a main task that emphasizes two principles:
- orthogonality: the identified subtask is as independent from the rest of the uncompleted main task as possible. This allows it to be executed in isolation without requiring any other subtasks to be completed first.
- small input/output footprint: the identified subtask has a small input and output footprint, meaning that it requires little information to be provided to it, and provides compact output. This reduces the amount of context needed to understand the subtask and its results.
- smaller subtask: the identified subtask is smaller in scope than the main task (i.e. it's not identical to the main task), even if the main task seems simple.
""".strip()


@dataclass(frozen=True)
class ActionDecision:
    """Decision for an action."""

    action_choice: str
    comment: str
    additional_thoughts: str | None = None

    @cached_property
    def action_name(self) -> str:
        """Name of the action chosen."""
        return (
            self.action_choice.split(":")[0]
            if ":" in self.action_choice
            else self.action_choice
        )

    @cached_property
    def action_args(self) -> dict[str, str]:
        """Arguments of the action chosen."""
        action_args: dict[str, str] = {}
        if self.action_name in [
            ActionName.MESSAGE_TASK_OWNER.value,
            ActionName.MESSAGE_SUBTASK_EXECUTOR.value,
            ActionName.REPORT_MAIN_TASK_COMPLETE.value,
        ]:
            action_args["message"] = (
                self.action_choice.replace(f"{self.action_name}:", "")
                .strip()
                .strip('"')
            )
            # self.action_choice.split(":")[1].strip().strip('"')
        return action_args

    @classmethod
    def from_yaml_str(cls, yaml_str: str) -> Self:
        """Create an action decision from a YAML string."""
        data = DEFAULT_YAML.load(yaml_str)
        if (
            additional_thoughts := data.get("additional_thoughts")
        ) and "NONE" in additional_thoughts:
            data["additional_thoughts"] = None
        return cls(**data)

    def validate_action(self, valid_actions: Iterable[str]) -> None:
        """Validate that the action is allowed."""
        for allowed_action in valid_actions:
            if self.action_choice.startswith(allowed_action):
                return
        raise ValueError(
            "Action choice validation failed.\n"
            f"{valid_actions=}\n"
            f"{self.action_choice=}\n"
        )


@dataclass
class ActionResult:
    """Result of an action."""

    pause_execution: PauseExecution
    new_events: list[Event[Any]]
    task_completed: bool


class OrchestratorInformationSection(Enum):
    """Information sections available to orchestrators."""

    KNOWLEDGE = "KNOWLEDGE: the orchestrator's background knowledge—usually lessons learned from performing task(s) similar to the current task. The information may or may not be relevant to the specific main task, but is provided as support for the orchestrator's decisionmaking."
    MAIN_TASK_DESCRIPTION = f"MAIN TASK DESCRIPTION: a description of information about the main task that the orchestrator has learned so far from the {Concept.MAIN_TASK_OWNER.value}. This may NOT be a complete description of the main task, so the orchestrator must always take into account if there is enough information for performing its actions. Additional information may also be in the {Concept.RECENT_EVENTS_LOG.value}, as messages from the main task owner."
    SUBTASKS = "SUBTASKS: a list of all subtasks that have been identified by the orchestrator so far; for each one, there is a high-level description of what must be done, as well as the subtask's status. This is not an exhaustive list of all required subtasks for the main task; there may be additional subtasks that are required. This list is automatically maintained and updated by a background process."
    RECENT_EVENTS_LOG = f"{Concept.RECENT_EVENTS_LOG.value}: a log of recent events that have occurred during the execution of the task. This can include status updates for subtasks, messages from the main task owner, and the orchestrator's own previous thoughts/decisions."
    FOCUSED_SUBTASK = f"{Concept.FOCUSED_SUBTASK.value}: the subtask that the orchestrator is currently focused on. This is the subtask that the orchestrator is currently thinking about and making decisions for. The orchestrator can only focus on one subtask at a time, and cannot perform actions on subtasks that it is not currently focused on."
    FOCUSED_SUBTASK_FULL_DISCUSSION_LOG = f"{Concept.FOCUSED_SUBTASK_DISCUSSION_LOG.value}: a log of the full discussion for the focused subtask between the orchestrator and the subtask executor."


@dataclass(frozen=True)
class SubtaskIdentifcationResult:
    """Result of subtask identification."""

    identified_subtask: str
    comment: str
    input_artifacts: list[Artifact]

    @classmethod
    def from_yaml_str(cls, yaml_str: str) -> Self:
        """Create a subtask identification result from a YAML string."""
        data = DEFAULT_YAML.load(yaml_str)
        data["input_artifacts"] = (
            [Artifact.from_serialized_data(artifact) for artifact in input_artifacts]
            if (input_artifacts := data["input_artifacts"])
            else []
        )
        return cls(**data)


class OrchestratorReasoningGenerationNotes(Enum):
    """Notes for orchestrator reasoning generation."""

    OVERVIEW = ReasoningGenerationNotes.OVERVIEW.value.format(
        role=Concept.ORCHESTRATOR.value
    )
    ACTION_RESTRICTIONS = f"The final action that the orchestrator decides on MUST be one of the {Concept.ORCHESTRATOR_ACTIONS.value} described above. The orchestrator cannot perform any other actions."
    TASK_COMPLETION_RESTRICTIONS = f"No matter how simple the {Concept.MAIN_TASK.value} is, it can only be done by being split into subtasks before it can be reported as complete. The orchestrator can only report the {Concept.MAIN_TASK.value} as complete if {Concept.ARTIFACT.value}s have been generated from the completion of subtasks."
    FOCUSED_SUBTASK_RESTRICTIONS = f"The orchestrator cannot directly change the {Concept.FOCUSED_SUBTASK.value}. To focus on a different subtask, it must first use the {ActionName.PAUSE_SUBTASK_DISCUSSION.value} action first. Overall, the orchestrator should be focused on helping the EXECUTOR of the {Concept.FOCUSED_SUBTASK.value}, and will need strong reason to change its focus."
    INFORMATION_RESTRICTIONS = (
        ReasoningGenerationNotes.INFORMATION_RESTRICTIONS.value.format(
            role=Concept.ORCHESTRATOR.value,
            INFORMATION_SECTIONS=Concept.ORCHESTRATOR_INFORMATION_SECTIONS.value,
        )
    )
    TERM_REFERENCES = ReasoningGenerationNotes.TERM_REFERENCES.value.format(
        role=Concept.ORCHESTRATOR.value,
        example_section_1=Concept.MAIN_TASK.value,
        example_section_2="KNOWLEDGE section",
    )
    SUBTASK_STATUS_INFO = f"Typically, subtasks that are {TaskWorkStatus.COMPLETED.value}, {TaskWorkStatus.CANCELLED.value}, {TaskWorkStatus.IN_PROGRESS.value}, or {TaskWorkStatus.IN_VALIDATION.value} do not need immediate attention unless the orchestrator discovers information that changes the status of the subtask. Subtasks that are {TaskWorkStatus.BLOCKED.value} will need action from the orchestrator to start or resume execution respectively."
    STEPS_RESTRICTIONS = ReasoningGenerationNotes.STEPS_RESTRICTIONS.value
    PROCEDURAL_SCRIPTING = ReasoningGenerationNotes.PROCEDURAL_SCRIPTING.value.format(
        role=Concept.ORCHESTRATOR.value
    )


@dataclass
class ReasoningGenerator:
    """Generates reasoning for various parts of task orchestration."""

    _orchestrator: "Orchestrator"
    """Orchestrator for which to generate reasoning. Must not be modified."""

    @property
    def default_mode_info_sections(self) -> str:
        """Basic information orchestrators in default state have access to."""
        template = f"""
        - {OrchestratorInformationSection.KNOWLEDGE.value}
        - {OrchestratorInformationSection.MAIN_TASK_DESCRIPTION.value}
        - {OrchestratorInformationSection.SUBTASKS.value}
        - {OrchestratorInformationSection.RECENT_EVENTS_LOG.value}
        """
        return dedent_and_strip(template)

    @property
    def subtask_mode_info_sections(self) -> str:
        """Basic information orchestrators in subtask discussion mode have access to."""
        template = f"""
        - {OrchestratorInformationSection.KNOWLEDGE.value}
        - {OrchestratorInformationSection.MAIN_TASK_DESCRIPTION.value}
        - {OrchestratorInformationSection.SUBTASKS.value}
        - {OrchestratorInformationSection.RECENT_EVENTS_LOG.value}
        - {OrchestratorInformationSection.FOCUSED_SUBTASK.value}
        - {OrchestratorInformationSection.FOCUSED_SUBTASK_FULL_DISCUSSION_LOG.value}
        """
        return dedent_and_strip(template)

    def info_sections(self, mode: ActionModeName) -> str:
        """Basic information orchestrators have access to."""
        if mode == ActionModeName.SUBTASK_DISCUSSION:
            return self.subtask_mode_info_sections
        return self.default_mode_info_sections

    def base_info(self, mode: ActionModeName) -> str:
        """Basic information orchestrators have access to."""
        template = f"""
        ## CONCEPTS:
        {{orchestrator_concepts}}

        ## {Concept.ORCHESTRATOR_INFORMATION_SECTIONS.value}:
        By default, the orchestrator has access to the following information. Note that all information here is read-only; the orchestrator cannot directly modify any of the information here as part of its reasoning progress.
        {{orchestrator_information_sections}}
        """
        return dedent_and_strip(template).format(
            orchestrator_concepts=ORCHESTRATOR_CONCEPTS,
            orchestrator_information_sections=self.info_sections(mode),
        )

    @property
    def default_mode_actions(self) -> str:
        """Actions available to the orchestrator in the default state."""
        return self._orchestrator.default_mode_actions.replace(
            "{completion_disabled_note}", ""
        )

    @property
    def role(self) -> Role:
        """Role of the orchestrator."""
        return self._orchestrator.role

    @property
    def subtask_mode_actions(self) -> str:
        """Actions available to the orchestrator in the subtask discussion state."""
        return self._orchestrator.subtask_mode_actions

    def generate_default_action_reasoning(self) -> str:
        """Generate reasoning for choosing an action in the default state."""
        context = """
        ## MISSION:
        {mission}

        {base_info}

        ## {ORCHESTRATOR_ACTIONS}:
        In its default state, the orchestrator can perform the following actions (these are all written in the second person, as if the orchestrator is reading them):
        ```start_of_orchestrator_actions
        {actions}
        ```end_of_orchestrator_actions
        """
        context = dedent_and_strip(context).format(
            mission=ORCHESTRATOR_INSTRUCTOR_MISSION,
            base_info=self.base_info(ActionModeName.DEFAULT),
            ORCHESTRATOR_ACTIONS=Concept.ORCHESTRATOR_ACTIONS.value,
            actions=self.default_mode_actions,
        )
        request = f"""
        ## REQUEST FOR YOU:
        {OrchestratorReasoningGenerationNotes.OVERVIEW.value}
        - {OrchestratorReasoningGenerationNotes.ACTION_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.TASK_COMPLETION_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.INFORMATION_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.TERM_REFERENCES.value}
        - {OrchestratorReasoningGenerationNotes.SUBTASK_STATUS_INFO.value}
        - {OrchestratorReasoningGenerationNotes.STEPS_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.PROCEDURAL_SCRIPTING.value}

        {{output_instructions}}
        """
        request = dedent_and_strip(request).format(
            output_instructions=REASONING_PROCESS_OUTPUT_INSTRUCTIONS.replace(
                "{{", "{"
            ).replace("}}", "}")
        )
        messages = [
            SystemMessage(content=context),
            SystemMessage(content=request),
        ]
        return query_and_extract_reasoning(
            messages,
            preamble=f"Generating reasoning for {self.role.value} in {ActionModeName.DEFAULT.value} state...\n{format_messages(messages)}",
            printout=VERBOSE,
        )

    def generate_subtask_action_reasoning(self) -> str:
        """Generate reasoning for choosing an action in the subtask discussion state."""
        context = """
        ## MISSION:
        {mission}

        {base_info}

        ## {ORCHESTRATOR_ACTIONS}:
        The orchestrator is currently in a mode where it is discussing its FOCUSED SUBTASK with the SUBTASK EXECUTOR. Currently, the orchestrator can perform the following actions:
        {actions}
        """
        context = dedent_and_strip(context).format(
            mission=ORCHESTRATOR_INSTRUCTOR_MISSION,
            base_info=self.base_info(ActionModeName.SUBTASK_DISCUSSION),
            ORCHESTRATOR_ACTIONS=Concept.ORCHESTRATOR_ACTIONS.value,
            actions=self.subtask_mode_actions,
        )
        request = f"""
        ## REQUEST FOR YOU:
        {OrchestratorReasoningGenerationNotes.OVERVIEW.value}
        - {OrchestratorReasoningGenerationNotes.ACTION_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.INFORMATION_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.TERM_REFERENCES.value}
        - {OrchestratorReasoningGenerationNotes.SUBTASK_STATUS_INFO.value}
        - {OrchestratorReasoningGenerationNotes.FOCUSED_SUBTASK_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.STEPS_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.PROCEDURAL_SCRIPTING.value}
        
        {{output_instructions}}
        """
        request = dedent_and_strip(request).format(
            output_instructions=REASONING_PROCESS_OUTPUT_INSTRUCTIONS.replace(
                "{{", "{"
            ).replace("}}", "}")
        )
        messages = [
            SystemMessage(content=context),
            SystemMessage(content=request),
        ]
        return query_and_extract_reasoning(
            messages,
            preamble=f"Generating reasoning for {self.role.value} in {ActionModeName.DEFAULT.value} state...\n{format_messages(messages)}",
            printout=VERBOSE,
        )

    def generate_subtask_identification_reasoning(self) -> str:
        """Generate reasoning for identifying a new subtask."""
        context = """
        ## MISSION:
        You are the instructor for an AI task orchestration agent. Your purpose is to provide a nested reasoning structure for the agent to think through how to identify the next subtask from the main task description.

        {base_info}

        ## MODULAR SUBTASK INDENTIFICATION PHILOSOPHY:
        {msi}

        """
        request = f"""
        ## REQUEST FOR YOU:
        Provide a nested, robust reasoning structure in YAML format for the orchestrator to a) understand what MSI is and follow its principles, and b) sequentially process the information in the information sections it has access to so that it can identify a new subtask that is not yet identified. This provides the internal thinking that an intelligent agent must go through so that they have all the relevant information on top of mind before they perform subtask identification. Some things to note:
        - {OrchestratorReasoningGenerationNotes.INFORMATION_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.TERM_REFERENCES.value}
        - In its current state, the orchestrator is not able to perform any other actions besides subtask identification and the reasoning preceeding it.
        - The {Concept.SUBTASK.value} must be smaller than the {Concept.MAIN_TASK.value}, even if the {Concept.MAIN_TASK.value} seems straightforward.
        - {OrchestratorReasoningGenerationNotes.STEPS_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.PROCEDURAL_SCRIPTING.value}
        - The orchestrator should only perform the subtask identification on the _last_ step, after it has considered _all_ the information it needs. No other actions need to be performed after subtask identification.

        {{output_instructions}}
        """
        messages = [
            SystemMessage(
                content=dedent_and_strip(context).format(
                    base_info=self.base_info(ActionModeName.DEFAULT),
                    msi=MODULAR_SUBTASK_IDENTIFICATION,
                )
            ),
            SystemMessage(
                content=dedent_and_strip(request).format(
                    output_instructions=REASONING_PROCESS_OUTPUT_INSTRUCTIONS.replace(
                        "{{", "{"
                    ).replace("}}", "}")
                )
            ),
        ]
        return query_and_extract_reasoning(
            messages,
            preamble=f"Generating subtask extraction reasoning...\n{format_messages(messages)}",
            printout=VERBOSE,
        )

    def generate_learning_reasoning(self) -> str:
        """Generate reasoning for learning after task completion."""
        context = """
        ## MISSION:
        You are the instructor for an AI task orchestration agent. Your purpose is to provide a nested reasoning structure for the agent to think through what it has learned from the completion of a task.

        ## CONCEPTS:
        {orchestrator_concepts}

        ## {ORCHESTRATOR_INFORMATION_SECTIONS}:
        By default, the orchestrator has access to the following information. Note that all information here is read-only; the orchestrator cannot directly modify any of the information here as part of its reasoning progress.
        - {MAIN_TASK_DESCRIPTION}: specification information about the {MAIN_TASK}, such as its requirements and technical details.
        - EVENTS LOG: a log of events that have occurred during the execution of the {MAIN_TASK}. This can include status updates for subtasks, messages from the {MAIN_TASK_OWNER}, and the orchestrator's own previous thoughts/decisions.
        - {SUBTASK} LIST: a list of {SUBTASK}s that were done (or attempted) for the {MAIN_TASK}, and detailed information about them. For each {SUBTASK}, the following information is available:
          - {SUBTASK} ID: a unique identifier for the {SUBTASK}.
          - SUMMARY: a high-level summary of what the {SUBTASK} is.
          - {STATUS}: the status of the {SUBTASK}. By this time, the {MAIN_TASK} has been completed, so all {STATUS}es will be either {COMPLETED} or {CANCELLED}.
          - {EXECUTOR} ID: the ID of the {EXECUTOR} that was responsible for the {SUBTASK}.
          - {ARTIFACT} LIST: a list of {ARTIFACT}s that were generated by the {EXECUTOR} of the {SUBTASK} while completing it.
          - DISCUSSION LOG: a log of the full discussion for the {SUBTASK} between the orchestrator and {SUBTASK}'s {EXECUTOR}.
        """
        context = dedent_and_strip(context).format(
            orchestrator_concepts=ORCHESTRATOR_CONCEPTS,
            ORCHESTRATOR_INFORMATION_SECTIONS=Concept.ORCHESTRATOR_INFORMATION_SECTIONS.value,
            MAIN_TASK_DESCRIPTION=OrchestratorInformationSection.MAIN_TASK_DESCRIPTION.value,
            MAIN_TASK=Concept.MAIN_TASK.value,
            MAIN_TASK_OWNER=Concept.MAIN_TASK_OWNER.value,
            SUBTASK=Concept.SUBTASK.value,
            STATUS=Concept.SUBTASK_STATUS.value,
            COMPLETED=TaskWorkStatus.COMPLETED.value,
            CANCELLED=TaskWorkStatus.CANCELLED.value,
            EXECUTOR=Concept.EXECUTOR.value,
            ARTIFACT=Concept.ARTIFACT.value,
        )
        request = """
        ## REQUEST FOR YOU:
        Provide a nested, robust reasoning structure in YAML format for the orchestrator to sequentially think through the information it has access to so that it has the appropriate mental context for figuring out what it has learned. This provides the internal thinking that an intelligent agent must go through so that they have all the relevant information on top of mind. Some things to note:
        - {INFORMATION_RESTRICTIONS}
        - {TERM_REFERENCES}
        - The overarching goal is to convey the learnings from the completion of the {MAIN_TASK} to another agent to maximize the chances of the other agent successfully completing other tasks like {MAIN_TASK}.
        - _Any_ information from the {ORCHESTRATOR_INFORMATION_SECTIONS} can be learned from, but the learnings must be general enough to be applicable to tasks that aren't identical to {MAIN_TASK}, but share similarities with it.
        - There should be three main types of lessons recorded (though they may or may not exist for any specific {MAIN_TASK}):
          - learnings about the {MAIN_TASK} itself
          - learnings about the individual {SUBTASK}s, including effective identification strategies for new subtasks
          - learnings about the {EXECUTOR}s—what they were good at, what they struggled with, and how to communicate with them
        - {EXECUTOR}s will persist in the system and may show up again in future subtasks; their IDs will remain the same across tasks.
        - {STEPS_RESTRICTIONS}
        - The intended audience for the reasoning process is the orchestrator, so it should be written in second person, directed at the orchestrator.
        - {PROCEDURAL_SCRIPTING}

        {output_instructions}
        """
        request = (
            dedent_and_strip(request)
            .replace("{output_instructions}", REASONING_PROCESS_OUTPUT_INSTRUCTIONS)
            .format(
                INFORMATION_RESTRICTIONS=OrchestratorReasoningGenerationNotes.INFORMATION_RESTRICTIONS.value,
                TERM_REFERENCES=OrchestratorReasoningGenerationNotes.TERM_REFERENCES.value,
                MAIN_TASK=Concept.MAIN_TASK.value,
                ORCHESTRATOR_INFORMATION_SECTIONS=Concept.ORCHESTRATOR_INFORMATION_SECTIONS.value,
                EXECUTOR=Concept.EXECUTOR.value,
                STEPS_RESTRICTIONS=OrchestratorReasoningGenerationNotes.STEPS_RESTRICTIONS.value,
                PROCEDURAL_SCRIPTING=OrchestratorReasoningGenerationNotes.PROCEDURAL_SCRIPTING.value,
                SUBTASK=Concept.SUBTASK.value,
            )
        )
        return query_and_extract_reasoning(
            (
                messages := [
                    SystemMessage(content=context),
                    SystemMessage(content=request),
                ]
            ),
            preamble=f"Generating learning reasoning...{format_messages(messages)}",
            printout=VERBOSE,
        )

    @staticmethod
    def generate_main_task_update_reasoning(printout: bool = True) -> str:
        """Generate reasoning for updating the main task. Currently unused."""
        context = f"""
        ## MISSION:
        You are the instructor for an AI task orchestration agent. Your purpose is to provide a nested reasoning structure for the agent to think through how to update the main task description based on new information in an event log.

        ## CONCEPTS:
        These are the concepts you should be familiar with:
        - {Concept.ORCHESTRATOR.value}: the agent that is responsible for managing the execution of a main task while communicating with the {Concept.MAIN_TASK_OWNER.value} to gather required information for the task.
        - {Concept.MAIN_TASK_OWNER.value}: the agent that owns the main task and is responsible for providing information to the orchestrator to help it execute the main task.
        - {Concept.MAIN_TASK.value}: the task that the orchestrator is responsible for executing.
        - {Concept.ARTIFACT.value}: some information at a location that is relevant to the execution of the {Concept.MAIN_TASK.value}. {Concept.ARTIFACT.value} have both a `description` and `location` parameters. {Concept.ARTIFACT.value}s are provided by the {Concept.MAIN_TASK_OWNER.value} during conversation in {Concept.TASK_MESSAGES.value}.

        ## {Concept.ORCHESTRATOR_INFORMATION_SECTIONS.value}:
        The orchestrator has access to the following information:
        - {Concept.MAIN_TASK_DEFINITION_OF_DONE.value}: a description of the criteria that must be met for the {Concept.MAIN_TASK.value} to be considered complete.
        - {Concept.MAIN_TASK_INFORMATION.value}: information on what the {Concept.MAIN_TASK.value} is about, including the goal of the task and any relevant background information. This section provides details that may be too granular for the {Concept.MAIN_TASK_DEFINITION_OF_DONE.value} section.
        - {Concept.TASK_MESSAGES.value}: a transcript of the messages between the orchestrator and the {Concept.MAIN_TASK_OWNER.value}.
        - {Concept.LAST_READ_MAIN_TASK_OWNER_MESSAGE.value}: the last message in the {Concept.TASK_MESSAGES.value} section sent by the {Concept.MAIN_TASK_OWNER.value} that has been read by the orchestrator. All messages after this message have not been read by the orchestrator yet.
        """

        task = f"""
        ## REQUEST FOR YOU:
        Provide a nested, robust reasoning structure in YAML format for the orchestrator to sequentially think through the information it has access to so that it has the appropriate mental context for updating the {Concept.MAIN_TASK_INFORMATION.value} and {Concept.MAIN_TASK_DEFINITION_OF_DONE.value} sections to reflect the new information in the {Concept.TASK_MESSAGES.value} that comes after {Concept.LAST_READ_MAIN_TASK_OWNER_MESSAGE.value}. This provides the internal thinking that an intelligent agent must go through so that they have all the relevant information on top of mind. Some things to note:
        - This reasoning process does not make the actual updates to the {Concept.MAIN_TASK_INFORMATION.value} and {Concept.MAIN_TASK_DEFINITION_OF_DONE.value} sections; it only figures out what updates are needed.
        - Both the {Concept.MAIN_TASK_INFORMATION} and {Concept.MAIN_TASK_DEFINITION_OF_DONE} sections may be outdated, hence the need to update them with the latest messages from the {Concept.MAIN_TASK_OWNER.value}.
        - {OrchestratorReasoningGenerationNotes.INFORMATION_RESTRICTIONS.value}
        - The orchestrator requires precise references to information it's been given, and it may need a reminder to check for specific parts; it's best to be explicit and use the _exact_ capitalized terminology to refer to concepts or information sections (e.g. "{Concept.MAIN_TASK.value}" or "{Concept.TASK_MESSAGES.value} section"); however, don't use capitalization as emphasis for any other terms.
        - {OrchestratorReasoningGenerationNotes.STEPS_RESTRICTIONS.value}
        - {OrchestratorReasoningGenerationNotes.PROCEDURAL_SCRIPTING.value}

        {{output_instructions}}
        """
        messages = [
            SystemMessage(content=dedent_and_strip(context)),
            SystemMessage(
                content=dedent_and_strip(task).format(
                    output_instructions=REASONING_PROCESS_OUTPUT_INSTRUCTIONS.replace(
                        "{{", "{"
                    ).replace("}}", "}")
                )
            ),
        ]
        return query_and_extract_reasoning(
            messages,
            preamble=f"Generating reasoning for updating the main task...\n{format_messages(messages)}",
            printout=printout,
        )


@dataclass
class OrchestratorState:
    """State of the orchestrator."""

    focused_subtask: Task | None = None
    new_event_count: int = 0


@dataclass(frozen=True)
class Orchestrator:
    """A recursively auto-specializing swarm agent."""

    blueprint: OrchestratorBlueprint
    task: Task
    files_parent_dir: Path
    delegator: Delegator
    state: OrchestratorState = field(default_factory=OrchestratorState)

    @property
    def focused_subtask(self) -> Task | None:
        """Focused subtask of the orchestrator."""
        return self.state.focused_subtask

    @property
    def new_event_count(self) -> int:
        """Number of new events."""
        return self.state.new_event_count

    @property
    def id(self) -> RuntimeId:
        """Runtime id of the orchestrator."""
        return RuntimeId(f"{self.blueprint.id}_{self.task.id}")

    @property
    def executor_max_rank(self) -> int | None:
        """Maximum rank of the orchestrator's task executors."""
        ranks: list[int | None] = []
        for subtask in self.task.subtasks:
            if subtask.work_status == TaskWorkStatus.COMPLETED:
                assert subtask.last_executor_rank is not None
                ranks.append(subtask.last_executor_rank)
                continue
            if subtask.work_status == TaskWorkStatus.CANCELLED:
                continue
            if subtask.executor is None:
                ranks.append(None)
                continue
            ranks.append(subtask.executor.rank)
        int_ranks = [rank for rank in ranks if rank is not None]
        # if some subtask has no ranked executor, it means it either has not been delegated or its executor is unranked
        return None if not int_ranks or len(int_ranks) < len(ranks) else max(int_ranks)

    @property
    def rank_limit(self) -> int | None:
        """Limit of how high the orchestrator can be ranked."""
        return self.task.rank_limit

    @property
    def rank(self) -> int | None:
        """Rank of the orchestrator."""
        # we always go with existing rank if available b/c executor_max_rank varies and could be < existing rank between runs
        if self.blueprint.rank is not None:
            return self.blueprint.rank
        if (
            rank := (
                None if self.executor_max_rank is None else 1 + self.executor_max_rank
            )
        ) is not None:
            assert (
                rank >= 1
            ), f"Orchestrator rank must be >= 1. For {self.id}, rank={rank}."
            if self.rank_limit is not None:
                rank = min(rank, self.rank_limit)
        return rank

    @property
    def reasoning(self) -> Reasoning:
        """Instructions for the orchestrator for various tasks."""
        return self.blueprint.reasoning

    @property
    def knowledge(self) -> Knowledge | None:
        """Learnings from past tasks."""
        return self.blueprint.knowledge

    @property
    def role(self) -> Role:
        """Role of the orchestrator."""
        return self.blueprint.role

    @property
    def core_template(self) -> str:
        """Template for the core state."""
        template = f"""
        ## MISSION:
        You are an advanced task orchestrator that specializes in managing the execution of a MAIN TASK and delegating its SUBTASKS to EXECUTORS that can execute those tasks, while communicating with the MAIN TASK OWNER to gather required information for the task. Your overall purpose is to facilitate task execution by communicating with both the MAIN TASK OWNER and SUBTASK EXECUTORS to complete the MAIN TASK as efficiently as possible.

        ## CONCEPTS:
        Here are some concepts that are specific to your role as an orchestrator:
        ```start_of_concepts
        {{orchestrator_state_concepts}}
        ```end_of_concepts

        ## KNOWLEDGE:
        In addition to the general background knowledge of your language model, you have the following, more specialized knowledge learned from performing task(s) similar to the current one. This knowledge is for reference only, and may or may not be applicable to the current task:
        ```start_of_knowledge
        {{knowledge}}
        ```end_of_knowledge

        ## MAIN TASK DESCRIPTION:
        Here is information about the main task you are currently working on:
        ```start_of_main_task_description
        {{task_specification}}
        ```end_of_main_task_description
        More recent information may be available in the RECENT EVENTS LOG below. These will be automatically integrated into the main task description when they are no longer recent.

        ## SUBTASKS:
        - SUBTASKS are tasks that must be executed in order to complete the MAIN TASK.
        - You do NOT execute subtasks yourself, but instead delegate them to SUBTASK EXECUTORS.
        - Typically, tasks that are COMPLETED, CANCELLED, IN_PROGRESS, or IN_VALIDATION do not need attention unless you discover information that changes the status of the subtask.
        - In contrast, tasks that are NEW or BLOCKED will need action from you to start/continue execution.
        - This is not an exhaustive list of all required subtasks for the main task; you may discover additional subtasks that must be done to complete the main task.

        ### SUBTASKS ({TaskWorkStatus.COMPLETED.value}):
        These tasks have been reported as completed, and validated as such by the validator; use this section as a reference for progress in the main task.
        ```start_of_completed_subtasks
        {{completed_subtasks}}
        ```end_of_completed_subtasks

        ### SUBTASKS ({TaskWorkStatus.CANCELLED.value}):
        You have previously cancelled these subtasks for various reason and they will not be done.
        ```start_of_cancelled_subtasks
        {{cancelled_subtasks}}
        ```end_of_cancelled_subtasks

        ### SUBTASKS ({TaskWorkStatus.IN_VALIDATION.value}):
        These subtasks have been reported as completed by executors, but are still being validated by validators.
        ```start_of_in_validation_subtasks
        {{in_validation_subtasks}}
        ```end_of_in_validation_subtasks

        ### SUBTASKS ({TaskWorkStatus.IN_PROGRESS.value}):
        These are subtasks that you have delegated to other executors and that are currently being executed by them.
        ```start_of_delegated_subtasks
        {{delegated_subtasks}}
        ```end_of_delegated_subtasks

        ### SUBTASKS ({TaskWorkStatus.BLOCKED.value}):
        These subtasks are blocked by some issue, and execution cannot continue until the issue is resolved, typically by discussing the blocker and/or creating a new subtask to resolve the blocker.
        ```start_of_blocked_subtasks
        {{blocked_subtasks}}
        ```end_of_blocked_subtasks
        """
        return dedent_and_strip(template)

    @property
    def core_state(self) -> CoreState:
        """Overall state of the orchestrator."""
        return CoreState(
            id=self.id,
            knowledge=str(self.knowledge),
            main_task=self.task,
            subtasks=self.task.subtasks,
            template=self.core_template,
        )

    @property
    def files_dir(self) -> Path:
        """Directory for files related to the orchestrator."""
        return make_if_not_exist(
            self.files_parent_dir / self.blueprint.id / self.task.id
        )

    @property
    def serialization_location(self) -> Path:
        """Return the location where the orchestrator should be serialized."""
        return self.files_dir / "blueprint.yaml"

    @property
    def output_dir(self) -> Path:
        """Output directory of the orchestrator."""
        return make_if_not_exist(self.files_dir / "output")

    @property
    def workspace_dir(self) -> Path:
        """Workspace directory of the orchestrator."""
        return make_if_not_exist(self.files_dir / "workspace")

    @property
    def name(self) -> str:
        """Name of the orchestrator."""
        return self.blueprint.name

    @property
    def auto_wait(self) -> bool:
        """Whether to automatically wait for new events."""
        return self.blueprint.auto_wait

    def make_files_dirs(self) -> None:
        """Make the files directory for the orchestrator."""
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.workspace_dir.mkdir(parents=True, exist_ok=True)

    def serialize(self) -> dict[str, Any]:
        """Serialize the orchestrator to a JSON dict."""
        return self.blueprint.serialize()

    def generate_learning_reasoning(self) -> str:
        """Generate reasoning for learning from tasks."""
        return self.reasoning_generator.generate_learning_reasoning()

    @property
    def learning_reasoning(self) -> str:
        """Reasoning for learning from tasks."""
        if not self.blueprint.reasoning.learning:
            self.blueprint.reasoning.learning = self.generate_learning_reasoning()
        return self.blueprint.reasoning.learning

    @property
    def knowledge_generation_context(self) -> str:
        """Context for generating knowledge."""
        context = """
        ## MISSION:
        You are an advanced task orchestrator that specializes in managing the status of a {MAIN_TASK} and coordinating the execution of its {SUBTASK}s.

        ## MODE:
        Currently, the {MAIN_TASK} has been completed, and you are in the process of learning from its completion process.

        ## {MAIN_TASK_DESCRIPTION}:
        Here is information about the {MAIN_TASK} that has been completed:
        ```start_of_main_task_description
        {main_task_description}
        ```end_of_main_task_description

        ## EVENTS LOG:
        ```start_of_events_log
        {events_log}
        ```end_of_events_log

        ## {SUBTASK} LIST:
        These are the {SUBTASK}s that were done (or attempted) for the {MAIN_TASK}, and detailed information about them.
        ```start_of_subtask_list
        {subtask_list}
        ```end_of_subtask_list
        """

        def as_subtask_review_printout(subtask: Task) -> str:
            """String representation of a subtask as it would appear when reviewing subtask history."""
            assert subtask.name
            assert subtask.work_status in {
                TaskWorkStatus.COMPLETED,
                TaskWorkStatus.CANCELLED,
            }, f"Subtask '{self.name}` is not yet {TaskWorkStatus.COMPLETED.value} or {TaskWorkStatus.CANCELLED.value}, so it cannot be reviewed."

            template = """
            - "Subtask Id": {id}
              "Summary": {name}
              "Status": {work_status}
              "Executor Id": {executor_id}
              "Artifact List":
            {artifacts}
              "Discussion Log": |-
            {discussion_log}
            """
            discussion_log = subtask.event_log.to_str_with_pov(
                pov_id=subtask.owner_id,
                other_id=subtask.last_executor_id,
                other_name=Concept.EXECUTOR.value,
            )
            return dedent_and_strip(template).format(
                id=subtask.id,
                name=subtask.name,
                work_status=subtask.work_status.value,
                executor_id=subtask.last_executor_id,
                artifacts=indent(subtask.output_artifacts_printout, "  "),
                discussion_log=indent(discussion_log, "    "),
            )

        main_events_log_printout = self.task.reformat_event_log(
            self.event_log, pov=Concept.EXECUTOR
        )
        if any(
            subtask.last_executor_id in main_events_log_printout
            for subtask in self.subtasks
        ):
            raise NotImplementedError(
                "TODO: possibly handle subtask executor replacement during knowledge determination. (May not be necessary.)"
            )

        subtask_review_printouts = [
            as_subtask_review_printout(subtask) for subtask in self.task.subtasks
        ]
        subtask_review_printouts = "\n".join(subtask_review_printouts)
        return dedent_and_strip(context).format(
            MAIN_TASK=Concept.MAIN_TASK.value,
            SUBTASK=Concept.SUBTASK.value,
            MAIN_TASK_DESCRIPTION=OrchestratorInformationSection.MAIN_TASK_DESCRIPTION.value,
            main_task_description=self.task.description,
            events_log=main_events_log_printout,
            subtask_list=subtask_review_printouts,
        )

    def brainstorm_knowledge(self) -> str:
        """Brainstorm knowledge for the orchestrator."""
        context = self.knowledge_generation_context
        request = """
        ## REQUEST FOR YOU:
        Use the following reasoning process to learn from the completion of the {MAIN_TASK}:
        ```start_of_reasoning_process
        {reasoning_process}

        Remember to be specific and use exact IDs when referencing {SUBTASK}s and {EXECUTOR}s.
        ```end_of_reasoning_process

        {reasoning_output_instructions}
        """
        request = (
            dedent_and_strip(request)
            .replace("{reasoning_output_instructions}", REASONING_OUTPUT_INSTRUCTIONS)
            .format(
                MAIN_TASK=Concept.MAIN_TASK.value,
                reasoning_process=self.learning_reasoning,
                SUBTASK=Concept.SUBTASK.value,
                EXECUTOR=Concept.EXECUTOR.value,
            )
        )
        messages = [
            SystemMessage(content=context),
            SystemMessage(content=request),
        ]
        output = query_model(
            model=SUPER_CREATIVE_MODEL,
            messages=messages,
            preamble=f"Brainstorming knowledge from completion of {self.name}...\n{format_messages(messages)}",
            color=SWARM_COLOR,
            printout=VERBOSE,
        )
        output = extract_blocks(output, "start_of_reasoning_output")
        assert output and len(output) == 1, "Exactly one reasoning output is expected."
        return output[0]

    def generate_knowledge(self) -> Knowledge:
        """Generate knowledge for the orchestrator."""
        context = self.knowledge_generation_context
        brainstorming = """
        ## BRAINSTORMING:
        Here is some brainstorming for what I have learned:
        ```start_of_brainstorming
        {brainstorming}
        ```end_of_brainstorming
        """
        brainstorming = dedent_and_strip(brainstorming).format(
            brainstorming=self.brainstorm_knowledge()
        )
        request = """
        ## REQUEST FOR YOU:
        Using the brainstorming as a starting point, figure out the lessons you have learned from the completion of the {MAIN_TASK}, using the following guidelines:
        - There should be three main types of lessons recorded (though they may or may not exist for any specific {MAIN_TASK}):
          - learnings about the {EXECUTOR}s—what they were good at, what they struggled with, and how to communicate with them
          - learnings about the {MAIN_TASK} itself
          - learnings about the individual {SUBTASK}s, including effective identification strategies for new subtasks
        - Be empirical and objective, not aspirational; be specific and precise in lessons learned—avoid vague general principles.
        - Avoid referring to specific {ARTIFACT}s generated, as future orchestrators will not have access to those artifacts.
        - When referring to {EXECUTOR}s, use their exact IDs. Future orchestrators may encounter the same {EXECUTOR}s.
        - The output should be in second person, as if you are speaking directly to a future orchestrator.
        - Avoid using {SUBTASK} IDs, as information about {SUBTASK}s are discarded after this exercise. Instead, refer to {SUBTASK}s by what they involved.
        - Avoiding referring to the {MAIN_TASK} as "{MAIN_TASK}", because future orchestrators may have a different {MAIN_TASK}; instead, refer to what the task involves.

        Output the knowledge you have learned from the completion of the {MAIN_TASK} in _two_ blocks.
        The first block contains learnings about specific, individual {EXECUTOR}s.
        ```start_of_executor_learnings_output
        - {{executor_learning_1}}
        - {{executor_learning_2}}
        - [... etc.]
        ```end_of_executor_learnings_output
        The second block contains other learnings that aren't specific to an individual {EXECUTOR}.
        ```start_of_other_learnings_output
        - {{other_learning_1}}
        - {{other_learning_2}}
        - [... etc.]
        ```end_of_other_learnings_output
        Any other comments or thoughts can be added before or after the output blocks.
        """
        request = dedent_and_strip(request).format(
            MAIN_TASK=Concept.MAIN_TASK.value,
            EXECUTOR=Concept.EXECUTOR.value,
            SUBTASK=Concept.SUBTASK.value,
            ARTIFACT=Concept.ARTIFACT.value,
        )
        messages = [
            SystemMessage(content=context),
            AIMessage(content=brainstorming),
            SystemMessage(content=request),
        ]
        output = query_model(
            model=SUPER_CREATIVE_MODEL,
            messages=messages,
            preamble=f"Generating knowledge from completion of {self.name}...\n{format_messages(messages)}",
            printout=VERBOSE,
            color=SWARM_COLOR,
        )
        # output = extract_blocks(output, "start_of_learnings_output")
        # assert output and len(output) == 1, "Exactly one learning output is expected."
        # return output[0]
        executor_output = extract_blocks(output, "start_of_executor_learnings_output")
        assert (
            executor_output and len(executor_output) == 1
        ), "Exactly one executor output is expected."
        other_output = extract_blocks(output, "start_of_other_learnings_output")
        assert (
            other_output and len(other_output) == 1
        ), "Exactly one other output is expected."
        return Knowledge(
            executor_learnings=executor_output[0], other_learnings=other_output[0]
        )

    def save_blueprint(self, update_blueprint: bool = True) -> None:
        """Serialize the orchestrator to YAML."""
        if not update_blueprint:
            assert (
                self.blueprint.rank is not None
            ), "Orchestrator rank must not be None when saving."
            DEFAULT_YAML.dump(self.serialize(), self.serialization_location)
            return

        self.blueprint.rank = self.rank
        # assume that at the point of saving, all executors have been saved and ranked so we have enough info to calculate the orchestrator's rank
        assert (
            self.blueprint.rank is not None
        ), "Orchestrator rank must not be None when saving."

        if not self.blueprint.knowledge:
            self.blueprint.knowledge = self.generate_knowledge()
        if not self.blueprint.description:
            self.blueprint.description = generate_agent_description(
                self.task.information
            )
        DEFAULT_YAML.dump(self.serialize(), self.serialization_location)

    def accepts(self, task: Task) -> bool:
        """Decides whether the orchestrator accepts a task."""
        return decide_acceptance(task, self)

    @property
    def recent_events_size(self) -> int:
        """Number of recent events to display."""
        return self.blueprint.recent_events_size

    @property
    def state_update_frequency(self) -> int:
        """How often to update the state of the task, in terms of new events."""
        return max(1, int(self.recent_events_size / 2))

    @property
    def recent_events(self) -> EventLog:
        """Recent events in the event log."""
        return self.task.event_log.recent(self.recent_events_size)

    @property
    def recent_event_status(self) -> str:
        """Status of recent events."""
        template = """
        ## RECENT EVENTS LOG:
        This is a log of recent events that have occurred during the execution of the main task. This is NOT a complete log—use the main task description and subtask statuses to get a complete picture of the current state of the work:
        ```start_of_recent_events_log
        {event_log}
        ```end_of_recent_events_log
        """
        return dedent_and_strip(template).format(
            event_log=self.task.reformat_event_log(
                self.recent_events, pov=Concept.EXECUTOR
            )
        )

    @property
    def default_mode_status(self) -> str:
        """Default status of the orchestrator."""
        template = """
        {core_state}

        {recent_event_status}
        """
        return dedent_and_strip(template).format(
            core_state=str(self.core_state),
            recent_event_status=self.recent_event_status,
        )

    @property
    def default_action_names(self) -> set[str]:
        """Names of actions available in the default state."""
        return {
            ActionName.IDENTIFY_NEW_SUBTASK.value,
            ActionName.MESSAGE_TASK_OWNER.value,
            ActionName.START_DISCUSSION_FOR_SUBTASK.value,
            ActionName.REPORT_MAIN_TASK_COMPLETE.value,
        }

    @property
    def default_mode_actions(self) -> str:
        """Actions available in the default mode."""
        actions = """
        - `{IDENTIFY_NEW_SUBTASK}`: identify a new subtask from the MAIN TASK that is not yet on the existing subtask list. This adds the subtask to the list and begins a discussion thread with the subtask's executor to start work on the task.
        - `{START_DISCUSSION_FOR_SUBTASK}: "{{id}}"`: open a discussion thread with a subtask's executor, which allows you to exchange information about the subtask. {{id}} must be replaced with the id of the subtask to be discussed.
        - `{MESSAGE_TASK_OWNER}: "{{message}}"`: send a message to the MAIN TASK OWNER to gather or clarify information about the task, *or* to report that you cannot complete the task. {{message}} must be replaced with the message you want to send.
        - `{REPORT_MAIN_TASK_COMPLETE}: "{{message}}"`: mark the MAIN TASK as complete, and send a message containing descriptions and the exact location of the final output ARTIFACT for the task. This can only be done **after** the final ARTIFACT for the task's output has been created in the SUBTASKS section.
        - `{WAIT}`: do nothing until the next event from an executor or the MAIN TASK OWNER.
        When sending a message, always refer to the MAIN TASK as 'the task' rather than 'MAIN TASK', because the MAIN TASK OWNER might have other tasks that they own.
        """
        return dedent_and_strip(
            actions.format(
                IDENTIFY_NEW_SUBTASK=ActionName.IDENTIFY_NEW_SUBTASK.value,
                # IDENTIFIED=TaskWorkStatus.IDENTIFIED.value,
                START_DISCUSSION_FOR_SUBTASK=ActionName.START_DISCUSSION_FOR_SUBTASK.value,
                MESSAGE_TASK_OWNER=ActionName.MESSAGE_TASK_OWNER.value,
                REPORT_MAIN_TASK_COMPLETE=ActionName.REPORT_MAIN_TASK_COMPLETE.value,
                WAIT=ActionName.WAIT.value,
                MAIN_TASK_OWNER=Concept.MAIN_TASK_OWNER.value,
            )
        )

    @property
    def action_reasoning_template(self) -> str:
        """Template for action reasoning."""
        template = """
        Use the following reasoning process to decide what to do next:
        ```start_of_reasoning_process
        {action_choice_core}
        ```end_of_reasoning_process
        **Important:** Remember that for the sake of following a consistent process, the MAIN TASK needs at least one subtask to be identified before it can be completed (usually more). As an orchestrator, you cannot execute any part of the MAIN TASK yourself, including finishing the MAIN TASK.

        {reasoning_output_instructions}

        After this block, you must include the action you have decided on, in this format:
        ```start_of_action_choice_output
        comment: |-
          {{comment}}
        action_choice: |-
          {{action_choice}} 
        ```end_of_action_choice_output
        `action_choice` must be one of the {ORCHESTRATOR_ACTIONS} listed above, in the same format.
        Any additional comments or thoughts can be added before or after the output blocks.
        """
        return dedent_and_strip(template).replace(
            "{reasoning_output_instructions}", REASONING_OUTPUT_INSTRUCTIONS
        )

    @property
    def reasoning_generator(self) -> ReasoningGenerator:
        """Reasoning generator for the orchestrator."""
        return ReasoningGenerator(_orchestrator=self)

    def generate_default_action_reasoning(self) -> str:
        """Generate reasoning for choosing an action in the default state."""
        return self.reasoning_generator.generate_default_action_reasoning()

    @property
    def default_action_reasoning(self) -> str:
        """Prompt for choosing an action in the default mode."""
        if not self.blueprint.reasoning.default_action_choice:
            self.blueprint.reasoning.default_action_choice = (
                self.generate_default_action_reasoning()
            )
        return self.action_reasoning_template.format(
            action_choice_core=self.blueprint.reasoning.default_action_choice,
            MAIN_TASK=Concept.MAIN_TASK.value,
            ORCHESTRATOR_ACTIONS=Concept.ORCHESTRATOR_ACTIONS.value,
        )

    @property
    def default_action_context(self) -> str:
        """Prompt for choosing an action in the default state."""
        template = """
        {default_mode_status}

        ## {ORCHESTRATOR_ACTIONS}:
        These are the actions you can currently perform.
        {default_mode_actions}
        """
        if any(
            subtask.work_status != TaskWorkStatus.COMPLETED
            for subtask in self.task.subtasks
        ):
            completion_disabled_note = "[**Disabled**: subtasks must be completed before the main task can be completed.]"
        elif len(self.task.subtasks) < 2:
            completion_disabled_note = "[**Disabled**: the main task must have had at least 2 subtasks identified before it can be completed.]"
        else:
            completion_disabled_note = ""
        return dedent_and_strip(template).format(
            default_mode_status=self.default_mode_status,
            ORCHESTRATOR_ACTIONS=Concept.ORCHESTRATOR_ACTIONS.value,
            default_mode_actions=self.default_mode_actions.replace(
                "{completion_disabled_note}", completion_disabled_note
            ),
        )

    @property
    def action_mode(self) -> ActionModeName:
        """What action state the orchestrator is in."""
        if self.focused_subtask:
            return ActionModeName.SUBTASK_DISCUSSION
        return ActionModeName.DEFAULT

    @property
    def focused_subtask_discussion(self) -> str:
        """Discussion of the focused subtask."""
        assert self.focused_subtask is not None
        assert self.focused_subtask.executor
        template = """
        ## FOCUSED SUBTASK:
        You are currently focusing on the following subtask:
        ```start_of_subtask_information
        {subtask_information}
        ```end_of_subtask_information

        ### FOCUSED SUBTASK FULL DISCUSSION LOG:
        Below is a complete log of the discussion of the FOCUSED SUBTASK so far. Some messages may overlap with the RECENT EVENTS LOG above, but this log has all messages related to the FOCUSED SUBTASK rather than just the most recent.
        ```start_of_subtask_discussion_log
        Executor Id: {blueprint_id}
        {subtask_discussion}
        ```end_of_subtask_discussion_log
        """
        return dedent_and_strip(template).format(
            subtask_information=self.focused_subtask.as_subtask_printout,
            blueprint_id=self.focused_subtask.executor.blueprint.id,
            subtask_discussion=self.focused_subtask.reformat_event_log(
                self.focused_subtask.event_log.messages, pov=Concept.MAIN_TASK_OWNER
            ),
        )

    @property
    def subtask_mode_status(self) -> str:
        """Status of the orchestrator in subtask discussion mode."""
        template = """
        {default_mode_status}

        {subtask_discussion}
        """
        assert self.focused_subtask is not None
        return dedent_and_strip(template).format(
            default_mode_status=self.default_mode_status,
            subtask_discussion=self.focused_subtask_discussion,
        )

    @property
    def subtask_mode_actions(self) -> str:
        """Actions available in subtask discussion mode."""
        actions = """
        - `{MESSAGE_SUBTASK_EXECUTOR}: "{{message}}"`: send a message to the {EXECUTOR} of the {FOCUSED_SUBTASK} to gather or clarify information about the {FOCUSED_SUBTASK}. {{message}} must be replaced with the message you want to send. **Note**: the {EXECUTOR} is only aware of its own {FOCUSED_SUBTASK}, not _your_ {MAIN_TASK}. From its perspective, the {FOCUSED_SUBTASK} is _its_ {MAIN_TASK}. Never refer your own {MAIN_TASK_OWNER} or {MAIN_TASK} in messages to the {EXECUTOR}.
        - `{PAUSE_SUBTASK_DISCUSSION}: "{{reason}}"`: pause the discussion of the {FOCUSED_SUBTASK} to either communicate with other subtask executors, the {MAIN_TASK_OWNER}, or to create a new subtask. The {FOCUSED_SUBTASK}'s discussion will be frozen, but can be resumed later. {{reason}} must be replaced with the reason for pausing the discussion, so that the orchestrator can remember why it paused the discussion when it resumes it later.
        - `{CANCEL_SUBTASK}: "{{reason}}"`: cancel the {FOCUSED_SUBTASK} for the given reason. {{reason}} must be replaced with the reason for cancelling the subtask.
        - `{MESSAGE_TASK_OWNER}: "{{message}}"`: send a message to the {MAIN_TASK_OWNER} to gather or clarify information about the MAIN TASK, *or* to report that you cannot complete the task. {{message}} must be replaced with the message you want to send.
        - `{WAIT}`: do nothing until the next event from the {FOCUSED_SUBTASK}.
        """
        return dedent_and_strip(actions).format(
            MAIN_TASK_OWNER=Concept.MAIN_TASK_OWNER.value,
            MAIN_TASK=Concept.MAIN_TASK.value,
            EXECUTOR=Concept.EXECUTOR.value,
            FOCUSED_SUBTASK=Concept.FOCUSED_SUBTASK.value,
            MESSAGE_SUBTASK_EXECUTOR=ActionName.MESSAGE_SUBTASK_EXECUTOR.value,
            MESSAGE_TASK_OWNER=ActionName.MESSAGE_TASK_OWNER.value,
            PAUSE_SUBTASK_DISCUSSION=ActionName.PAUSE_SUBTASK_DISCUSSION.value,
            CANCEL_SUBTASK=ActionName.CANCEL_SUBTASK.value,
            WAIT=ActionName.WAIT.value,
        )

    @property
    def subtask_action_context(self) -> str:
        """Context for choosing an action in subtask discussion mode."""
        template = """
        {subtask_mode_status}

        ## {ORCHESTRATOR_ACTIONS}:
        These are the actions you can currently perform.
        {subtask_mode_actions}
        """
        return dedent_and_strip(template).format(
            subtask_mode_status=self.subtask_mode_status,
            ORCHESTRATOR_ACTIONS=Concept.ORCHESTRATOR_ACTIONS.value,
            subtask_mode_actions=self.subtask_mode_actions,
        )

    @property
    def action_choice_context(self) -> str:
        """Context for choosing an action."""
        if self.focused_subtask:
            raise NotImplementedError(
                "TODO: check Executor Id is passed correctly (print out subtask_action_context)"
            )
            return self.subtask_action_context
        if self.action_mode == ActionModeName.DEFAULT:
            return self.default_action_context
        raise ValueError(
            f"Unknown action mode: {self.action_mode}\ntask: {self.task.description}"
        )

    def generate_subtask_action_reasoning(self) -> str:
        """Generate reasoning for choosing an action in subtask discussion mode."""
        return self.reasoning_generator.generate_subtask_action_reasoning()

    @property
    def subtask_action_reasoning(self) -> str:
        """Reasoning for choosing an action in subtask discussion mode."""
        if not self.blueprint.reasoning.subtask_action_choice:
            self.blueprint.reasoning.subtask_action_choice = (
                self.generate_subtask_action_reasoning()
            )
        return self.action_reasoning_template.format(
            action_choice_core=self.blueprint.reasoning.subtask_action_choice,
            MAIN_TASK=Concept.MAIN_TASK.value,
            ORCHESTRATOR_ACTIONS=Concept.ORCHESTRATOR_ACTIONS.value,
        )

    @property
    def action_choice_reasoning(self) -> str:
        """Prompt for choosing an action."""
        if self.focused_subtask:
            return self.subtask_action_reasoning
        if self.action_mode == ActionModeName.DEFAULT:
            return self.default_action_reasoning
        raise ValueError(
            f"Unknown action mode: {self.action_mode}\ntask: {self.task.description}"
        )

    def choose_action(self) -> ActionDecision:
        """Choose an action to perform."""
        messages = [
            SystemMessage(content=self.action_choice_context),
            SystemMessage(content=self.action_choice_reasoning),
        ]
        action_choice = query_model(
            model=PRECISE_MODEL,
            messages=messages,
            preamble=f"Choosing next action...\n{format_messages(messages)}",
            color=SWARM_COLOR,
        )
        if not (
            extracted_result := extract_blocks(
                action_choice, "start_of_action_choice_output"
            )
        ):
            raise ExtractionError("Could not extract action choice from the result.")
        return ActionDecision.from_yaml_str(extracted_result[0])

    @property
    def event_log(self) -> EventLog:
        """Events that have occurred during the execution of the task."""
        return self.task.event_log

    @property
    def id_generator(self) -> IdGenerator:
        """Id generator for the orchestrator."""
        return self.task.id_generator

    def message_task_owner(self, message: str) -> ActionResult:
        """Send message to main task owner."""
        return ActionResult(
            new_events=[self.to_owner_message(message)],
            pause_execution=PauseExecution(True),
            task_completed=False,
        )

    @property
    def subtask_identification_context(self) -> str:
        """Context for extracting a subtask."""
        template = """
        {default_status}

        ## MODULAR SUBTASK IDENTIFICATION PHILOSOPHY (MSI):
        {msi}
        """
        return dedent_and_strip(template).format(
            default_status=self.default_mode_status,
            msi=MODULAR_SUBTASK_IDENTIFICATION,
        )

    def generate_subtask_identification_reasoning(self) -> str:
        """Generate reasoning for extracting a subtask."""
        # we have this because subtask identification generation assumes that the mode is default, so logic might decohere otherwise
        assert (
            not self.focused_subtask
        ), "Cannot generate subtask identification reasoning in subtask discussion mode."
        return self.reasoning_generator.generate_subtask_identification_reasoning()

    @property
    def subtask_identification_reasoning(self) -> str:
        """Prompt for extracting a subtask."""
        if not self.blueprint.reasoning.subtask_extraction:
            self.blueprint.reasoning.subtask_extraction = (
                self.generate_subtask_identification_reasoning()
            )
        template = """
        Use the following reasoning process to decide what to do next:
        ```start_of_reasoning_process
        {subtask_extraction_core}
        Remember, the subtask must not be the same as the MAIN TASK itself, no matter how straightforward the MAIN TASK is.
        ```end_of_reasoning_process

        {reasoning_output_instructions}

        **Important**: for the sake of following a consistent process, a subtask _must_ be identified, even if the MAIN TASK seems straightforward.

        After this block, you must include the subtask you have identified for its executor. To the executor, the identified subtask becomes its own MAIN TASK, and you are the MAIN TASK OWNER of the subtask. The executor knows nothing about your original MAIN TASK. The subtask must be described in the following format:
        ```start_of_subtask_identification_output
        comment: |-
          {{comment}}
        input_artifacts:  # these are artifacts either given by the MAIN TASK OWNER or listed under COMPLETED SUBTASKs that the executor may need to complete the subtask; leave empty if there are none
        - {{input_artifact_1}}
        - {{input_artifact_2}}
        - [... etc.]
        identified_subtask: |-  # high-level, single-sentence description of the subtask
          {{identified_subtask}}
        ```end_of_subtask_identification_output
        Remember, the subtask should only include information from the MAIN TASK that is relevant to the executor; additional context may confuse the executor as to what is in scope.
        """
        return (
            dedent_and_strip(template)
            .replace("{reasoning_output_instructions}", REASONING_OUTPUT_INSTRUCTIONS)
            .format(
                subtask_extraction_core=self.blueprint.reasoning.subtask_extraction,
            )
        )

    @property
    def subtasks(self) -> TaskList:
        """Subtasks of the orchestrator."""
        return self.task.subtasks

    @property
    def validator_state(self) -> str:
        """State sent to the validator."""
        template = """
        ## MAIN TASK DESCRIPTION:
        Here is information about the main task being worked on:
        ```start_of_main_task_description
        {task_specification}
        ```end_of_main_task_description

        ## SUBTASKS:
        Here are the subtasks that have been identified so far:

        ### SUBTASKS (COMPLETED):
        ```start_of_completed_subtasks
        {completed_subtasks}
        ```end_of_completed_subtasks

        ### SUBTASKS (CANCELLED):
        ```start_of_cancelled_subtasks
        {cancelled_subtasks}
        ```end_of_cancelled_subtasks

        ### SUBTASKS (IN_VALIDATION):
        ```start_of_in_validation_subtasks
        {in_validation_subtasks}
        ```end_of_in_validation_subtasks

        ### SUBTASKS (IN_PROGRESS):
        ```start_of_delegated_subtasks
        {delegated_subtasks}
        ```end_of_delegated_subtasks

        ### SUBTASKS (BLOCKED):
        ```start_of_blocked_subtasks
        {blocked_subtasks}
        ```end_of_blocked_subtasks
        """

        completed_subtasks = str(
            self.subtasks.filter_by_status(TaskWorkStatus.COMPLETED)
        )
        cancelled_subtasks = str(
            self.subtasks.filter_by_status(TaskWorkStatus.CANCELLED)
        )
        in_validation_subtasks = str(
            self.subtasks.filter_by_status(TaskWorkStatus.IN_VALIDATION)
        )
        delegated_subtasks = str(
            self.subtasks.filter_by_status(TaskWorkStatus.IN_PROGRESS)
        )
        # new_subtasks = str(self.subtasks.filter_by_status(TaskWorkStatus.IDENTIFIED))
        blocked_subtasks = str(self.subtasks.filter_by_status(TaskWorkStatus.BLOCKED))
        return dedent_and_strip(template).format(
            task_specification=str(self.task),
            completed_subtasks=completed_subtasks,
            cancelled_subtasks=cancelled_subtasks,
            in_validation_subtasks=in_validation_subtasks,
            delegated_subtasks=delegated_subtasks,
            # new_subtasks=new_subtasks,
            blocked_subtasks=blocked_subtasks,
        )

    def validate_subtask_identification(self, subtask: str) -> WorkValidationResult:
        """Validate some work."""
        instructions = """
        {validator_state}

        ## REQUEST FOR YOU:
        Please check that the subtask identification is correct:
        - Subtask: {subtask}
        """
        instructions = dedent_and_strip(instructions).format(
            validator_state=self.validator_state,
            subtask=subtask,
        )
        return self.task.validator.validate(instructions)

    def add_subtask(self, subtask: Task) -> None:
        """Add a subtask to the orchestrator."""
        self.task.subtasks.items.append(subtask)

    def subtask_message(self, subtask: Task, message: str) -> Event[Message]:
        """Format a message to a subtask."""
        assert subtask.executor, "Cannot post message to subtask without an executor."
        event_id = generate_id(EventId, self.id_generator)
        return create_task_message(
            subtask, message, sender_id=self.id, event_id=event_id
        )

    def send_focused_subtask_message(
        self, message_text: str, initial: bool = False
    ) -> list[Event[TaskStatusChange]]:
        """Send a message to the executor for the focused subtask."""
        assert self.focused_subtask is not None
        message_event = self.subtask_message(self.focused_subtask, message_text)
        return send_subtask_message(
            self.focused_subtask, message_event=message_event, initial=initial
        )

    def focus_subtask(self, subtask: Task) -> Event[StartedSubtaskDiscussion]:
        """Focus on a subtask."""
        self.state.focused_subtask = subtask
        return Event(
            data=StartedSubtaskDiscussion(
                owner_id=self.id,
                subtask_id=subtask.id,
            ),
            generating_task_id=self.task.id,
            id=generate_id(EventId, self.id_generator),
        )

    def unfocus_subtask(self) -> Event[PausedSubtaskDiscussion]:
        """Unfocus on a subtask."""
        assert self.state.focused_subtask, "Can't unfocus without a focused subtask."
        subtask_id = self.state.focused_subtask.id
        self.state.focused_subtask = None
        return Event(
            data=PausedSubtaskDiscussion(
                owner_id=self.id,
                subtask_id=subtask_id,
            ),
            generating_task_id=self.task.id,
            id=generate_id(EventId, self.id_generator),
        )

    @property
    def executor_selection_reasoning(self) -> str:
        """Reasoning for selecting an executor."""
        if not self.blueprint.reasoning.executor_selection:
            self.blueprint.reasoning.executor_selection = (
                generate_executor_selection_reasoning()
            )
        return self.blueprint.reasoning.executor_selection

    @property
    def executor_memory(self) -> str | None:
        """Memory for the executor."""
        return (
            self.blueprint.knowledge.executor_learnings
            if self.blueprint.knowledge
            else None
        )

    def identify_new_subtask(self) -> ActionResult:
        """Identify a new subtask."""
        messages = [
            SystemMessage(content=self.subtask_identification_context),
            SystemMessage(content=self.subtask_identification_reasoning),
        ]
        new_subtask = query_model(
            model=PRECISE_MODEL,
            messages=messages,
            preamble=f"Extracting subtask...\n{format_messages(messages)}",
            color=SWARM_COLOR,
        )
        extracted_results = extract_blocks(
            new_subtask, "start_of_subtask_identification_output"
        )
        if not extracted_results:
            raise ExtractionError(
                f"Could not extract subtask from the result:\n{new_subtask}"
            )
        extracted_results = SubtaskIdentifcationResult.from_yaml_str(
            extracted_results[-1]
        )
        for artifact in extracted_results.input_artifacts:
            assert (
                not artifact.must_be_created
            ), f"Input artifacts must not be created.\nArtifact: {artifact}"
        identified_subtask = extracted_results.identified_subtask
        subtask_validation = self.validate_subtask_identification(identified_subtask)
        subtask_context = f'This task is a subtask of the following parent task:\n"""\n{self.task.initial_information}\n"""'
        subtask = Task(
            data=TaskData(
                name=identified_subtask,
                owner_id=self.id,
                rank_limit=None if self.rank_limit is None else self.rank_limit - 1,
                description=TaskDescription(information=identified_subtask),
                input_artifacts=extracted_results.input_artifacts,
                context=subtask_context,
            ),
            id_generator=self.id_generator,
            task_records_dir=self.task.task_records_dir,
            validator=self.task.validator,
        )
        subtask_identification_event = Event(
            data=SubtaskIdentification(
                owner_id=self.id,
                subtask=identified_subtask,
                subtask_id=subtask.id,
                validation_result=subtask_validation,
            ),
            generating_task_id=self.task.id,
            id=generate_id(EventId, self.id_generator),
        )
        if not subtask_validation.valid:
            return ActionResult(
                pause_execution=PauseExecution(False),
                new_events=[subtask_identification_event],
                task_completed=False,
            )

        self.delegator.assign_executor(
            subtask,
            self.recent_events_size,
            self.auto_wait,
            self.executor_selection_reasoning,
            self.executor_memory,
        )
        # send relevant artifacts as a message
        assert subtask.executor is not None, "Task executor assignment failed."
        self.add_subtask(subtask)
        subtask_focus_event = self.focus_subtask(subtask)
        initial_message = "Hi, please feel free to ask me any questions about the context of this task—I've only given you a brief description to start with, but I can provide more information if you need it."
        addendum = (
            f"\nHere are some existing artifacts that may be relevant for the task:\n{subtask.input_artifacts_printout}"
            if subtask.input_artifacts
            else ""
        )
        initial_message += addendum
        subtask_initiation_events = self.send_focused_subtask_message(
            message_text=initial_message,
            initial=True,
        )
        new_events = [
            subtask_identification_event,
            subtask_focus_event,
            *subtask_initiation_events,
        ]
        return ActionResult(
            pause_execution=PauseExecution(False),
            new_events=new_events,
            task_completed=False,
        )

    @property
    def awaitable_subtasks(self) -> TaskList:
        """Subtasks that can be awaited."""
        # if in default mode, awaitable subtasks are all in-progress subtasks
        if self.focused_subtask:
            return (
                TaskList([self.focused_subtask])
                if self.focused_subtask.work_status == TaskWorkStatus.IN_PROGRESS
                else TaskList()
            )
        if self.action_mode == ActionModeName.DEFAULT:
            return self.subtasks.filter_by_status(TaskWorkStatus.IN_PROGRESS)
        raise ValueError(
            f"Unknown action mode: {self.action_mode}\ntask: {self.task.description}"
        )

    @property
    def subtask_action_names(self) -> set[str]:
        """Names of actions available in subtask discussion mode."""
        return {
            ActionName.MESSAGE_SUBTASK_EXECUTOR.value,
            ActionName.PAUSE_SUBTASK_DISCUSSION.value,
            ActionName.MESSAGE_TASK_OWNER.value,
            ActionName.WAIT.value,
        }

    @property
    def action_names(self) -> set[str]:
        """Names of actions available to the orchestrator."""
        if self.focused_subtask:
            return self.subtask_action_names
        return self.default_action_names

    def message_subtask_executor(self, message: str) -> ActionResult:
        """Send message to executor for the focused subtask."""
        return ActionResult(
            new_events=self.send_focused_subtask_message(message),
            pause_execution=PauseExecution(False),
            task_completed=False,
            # new_work_status=TaskWorkStatus.IN_PROGRESS,
        )

    def report_main_task_complete(self, message: str) -> ActionResult:
        """Report the main task as complete."""
        assert (
            self.task.work_status == TaskWorkStatus.IN_PROGRESS
        ), "Can't report a task as complete if it isn't in progress."
        message_event = self.to_owner_message(message)
        return ActionResult(
            pause_execution=PauseExecution(True),
            new_events=[message_event],
            task_completed=True,
        )

    def act(self, decision: ActionDecision) -> ActionResult:
        """Act on a decision."""
        decision.validate_action(valid_actions=self.action_names)
        if decision.action_name == ActionName.MESSAGE_TASK_OWNER.value:
            return self.message_task_owner(decision.action_args["message"])
        if decision.action_name == ActionName.IDENTIFY_NEW_SUBTASK.value:
            return self.identify_new_subtask()
        if decision.action_name == ActionName.START_DISCUSSION_FOR_SUBTASK.value:
            raise NotImplementedError("TODO")
        if decision.action_name == ActionName.REPORT_MAIN_TASK_COMPLETE.value:
            return self.report_main_task_complete(decision.action_args["message"])
        if decision.action_name == ActionName.WAIT.value:
            raise NotImplementedError("TODO")
        if decision.action_name == ActionName.MESSAGE_SUBTASK_EXECUTOR.value:
            return self.message_subtask_executor(decision.action_args["message"])
        if decision.action_name == ActionName.PAUSE_SUBTASK_DISCUSSION.value:
            raise NotImplementedError("TODO")

        raise NotImplementedError("TODO")
        # > change task cancellation to task failing validation
        # > if a task is set to be complete, trigger validation agent automatically
        # > need to add fail reason for failed tasks
        # ....
        # (next_action_implementation) > pause subtask discussion: adds event that is a summary of the new items in the discussion to maintain state continuity
        # raise ValueError(f"Unknown action: {decision.action_name}")

    def from_owner_message(self, message: str) -> Event[Message]:
        """Create a message from the task owner."""
        return Event(
            data=Message(
                sender=self.task.owner_id,
                recipient=self.id,
                content=message,
            ),
            generating_task_id=self.task.id,
            id=generate_id(EventId, self.id_generator),
        )

    def to_owner_message(self, message: str) -> Event[Message]:
        """Create a message to the task owner."""
        return Event(
            data=Message(
                sender=self.id,
                recipient=self.task.owner_id,
                content=message,
            ),
            generating_task_id=self.task.id,
            id=generate_id(EventId, self.id_generator),
        )

    @property
    def first_new_event(self) -> Event[Any]:
        """First new event since the last update of the main task."""
        return self.event_log.events[-(self.new_event_count)]

    @property
    def last_read_message(self) -> Event[Message] | None:
        """Last message read by the orchestrator."""
        old_events = reversed(self.event_log.events[: -(self.new_event_count)])
        old_messages = (
            event for event in old_events if isinstance(event.data, Message)
        )
        return next(old_messages, None)

    def generate_main_task_description_update(
        self,
    ) -> tuple[TaskDescription, str | None] | None:
        """Generate an update to the main task description."""
        reasoning = f"""
        1. Review the {Concept.MAIN_TASK_INFORMATION.value} and the {Concept.MAIN_TASK_DEFINITION_OF_DONE.value} to recall the current status and objectives of the {Concept.MAIN_TASK.value}. Note any specific requirements or key details that may be affected by new information.
        2. Check the {Concept.LAST_READ_MAIN_TASK_OWNER_MESSAGE.value} to identify where in the {Concept.TASK_MESSAGES.value} section you will begin integrating new information. The messages that come after this will hold the updates you need to consider.
        3. Sequentially read and analyze the messages in the {Concept.TASK_MESSAGES.value} section that follow after the {Concept.LAST_READ_MAIN_TASK_OWNER_MESSAGE.value}. For each message:
           a. Determine whether the message contains new information or requests that change the nature or the details of the {Concept.MAIN_TASK.value}.
           b. Evaluate if the new information influences the completion criteria outlined in the {Concept.MAIN_TASK_DEFINITION_OF_DONE.value}.
           c. Note any information that requires clarification or follow-up from the {Concept.MAIN_TASK_OWNER.value} and formulate a message to send if necessary.
        4. Synthesize the new information from step 3 into a concise summary, highlighting the changes impacting the {Concept.MAIN_TASK.value}. Record how the {Concept.MAIN_TASK_INFORMATION.value} or {Concept.MAIN_TASK_DEFINITION_OF_DONE.value} may need to be adjusted based on this information.
        5. Review the synthesized summary and establish a mental update plan by correlating the necessary changes with either the {Concept.MAIN_TASK_INFORMATION.value} or {Concept.MAIN_TASK_DEFINITION_OF_DONE.value} sections.
           a. For each section, list out the points that will be updated.
           b. Organize these points to ensure they are logical and do not conflict with each other.
        """
        reasoning = dedent_and_strip(reasoning)

        # You are an advanced task orchestrator that specializes in managing the execution of a {Concept.MAIN_TASK.value} and delegating its {Concept.SUBTASK.value} to an {Concept.EXECUTOR.value} that can execute those tasks, while communicating with the {Concept.MAIN_TASK_OWNER.value} to gather required information for the {Concept.MAIN_TASK.value}.
        context = f"""
        ## MISSION:
        You are an advanced task orchestrator that specializes in managing the status of a {Concept.MAIN_TASK.value} and coordinating the execution of its {Concept.SUBTASK.value}s.

        ### MODE:
        Currently you are NOT communicating with the {Concept.MAIN_TASK_OWNER.value}, but reviewing recent communications with them to update the {Concept.MAIN_TASK_INFORMATION.value} and {Concept.MAIN_TASK_DEFINITION_OF_DONE.value} sections based on new information.

        ## {Concept.MAIN_TASK_INFORMATION.value}:
        {{main_task_information}}

        ## {Concept.MAIN_TASK_DEFINITION_OF_DONE.value}:
        {{main_task_dod}}

        ## {Concept.TASK_MESSAGES.value}
        Here are the messages with the {Concept.MAIN_TASK_OWNER.value}:
        ```start_of_task_messages
        {{recent_messages}}
        ```end_of_task_messages
        {Concept.LAST_READ_MAIN_TASK_OWNER_MESSAGE.value}: {{last_read_main_task_owner_message}}
        """
        context = dedent_and_strip(context).format(
            main_task_information=self.task.information,
            main_task_dod=self.task.definition_of_done,
            recent_messages=self.task.reformat_event_log(
                self.task.messages, pov=Concept.EXECUTOR
            ),
            last_read_main_task_owner_message=self.last_read_message
            or "No messages read.",
        )
        task = """
        ## REQUEST FOR YOU:
        Use the following reasoning process to determine what must be updated in the {MAIN_TASK_DESCRIPTION} and {MAIN_TASK_DEFINITION_OF_DONE} sections:
        ```start_of_reasoning_process
        {reasoning_process}
        ```end_of_reasoning_process

        {reasoning_output_instructions}

        After this block, if the reasoning process determined that there is new information about the {MAIN_TASK}, use the information from the reasoning process to rewrite the {MAIN_TASK_DESCRIPTION} and {MAIN_TASK_DEFINITION_OF_DONE} sections to reflect the new information, in this format:
        ```start_of_main_task_info
        main_task_information: |-
          {{updated main task information}}
        main_task_definition_of_done:
          - {{requirement 1}}
          - {{requirement 2}}
          - [... etc.]
        ```end_of_main_task_info

        If there is no new information about the {MAIN_TASK}, then return the following:
        ```start_of_main_task_info
        NO NEW INFORMATION
        ```end_of_main_task_info
        """
        task = (
            dedent_and_strip(task)
            .replace("{reasoning_output_instructions}", REASONING_OUTPUT_INSTRUCTIONS)
            .format(
                MAIN_TASK=Concept.MAIN_TASK.value,
                MAIN_TASK_DESCRIPTION=Concept.MAIN_TASK_INFORMATION.value,
                MAIN_TASK_DEFINITION_OF_DONE=Concept.MAIN_TASK_DEFINITION_OF_DONE.value,
                reasoning_process=reasoning,
            )
        )
        messages = [
            SystemMessage(content=context),
            SystemMessage(content=task),
        ]
        result = query_model(
            model=PRECISE_MODEL,
            messages=messages,
            preamble=f"Updating main task description...\n{format_messages(messages)}",
            color=SWARM_COLOR,
        )
        extracted_result = extract_blocks(result, "start_of_main_task_info")
        if not extracted_result:
            raise ExtractionError(
                f"Could not extract main task description from the result:\n{result}"
            )
        if "NO NEW INFORMATION" in extracted_result[-1]:
            return None
        try:
            extracted_result = DEFAULT_YAML.load(extracted_result[-1])
        except YAMLError as error:
            raise ExtractionError(
                f"Could not extract main task description dictionary from the result:\n{result}"
            ) from error
        return (
            TaskDescription(
                information=extracted_result["main_task_information"],
                definition_of_done=format_as_yaml_str(
                    extracted_result["main_task_definition_of_done"], YAML()
                ),
            ),
            (
                None
                if (followup_needed := extracted_result.get("needed_followup"))
                and "NONE" in followup_needed
                else followup_needed
            ),
        )

    def update_main_task_description(self) -> None:
        """Update the main task from new events."""
        update_result = self.generate_main_task_description_update()
        if update_result is None:
            return
        (
            updated_task_description,
            followup_needed,
        ) = update_result
        task_update_event = Event(
            data=TaskDescriptionUpdate(
                changing_agent=self.id,
                task_id=self.task.id,
                old_description=str(self.task.description.full),
                new_description=str(updated_task_description),
                reason=f"new information from latest events in {Concept.RECENT_EVENTS_LOG.value}",
            ),
            generating_task_id=self.task.id,
            id=generate_id(EventId, self.id_generator),
        )
        followup_event = (
            None
            if followup_needed is None
            else Event(
                data=Thought(
                    agent_id=self.id,
                    content=followup_needed,
                ),
                generating_task_id=self.task.id,
                id=generate_id(EventId, self.id_generator),
            )
        )
        self.task.description = updated_task_description
        self.event_log.add(task_update_event)
        if followup_event is not None:
            self.event_log.add(followup_event)

    def add_to_event_log(self, events: Sequence[Event[Any]]) -> None:
        """Add events to the event log."""
        self.task.event_log.add(*events)
        self.state.new_event_count += len(events)
        if self.new_event_count >= self.state_update_frequency:
            self.update_main_task_description()
            self.state.new_event_count = 0

    def add_thought(self, thought: str) -> None:
        """Add a thought to the event log."""
        self.add_to_event_log(
            [
                Event(
                    data=Thought(
                        agent_id=self.id,
                        content=thought,
                    ),
                    generating_task_id=self.task.id,
                    id=generate_id(EventId, self.id_generator),
                )
            ]
        )

    async def execute(self) -> ExecutionReport:
        """Execute the task."""
        while True:
            if self.auto_wait and self.awaitable_subtasks:
                executor_reports = [
                    asyncio.create_task(execute_and_validate(subtask))
                    for subtask in self.awaitable_subtasks
                    if subtask.executor is not None
                ]
                done_reports, _ = await asyncio.wait(
                    executor_reports, return_when=asyncio.FIRST_COMPLETED
                )
                done_reports = [report.result() for report in done_reports]
                executor_events = list(
                    chain(
                        *[
                            report.new_parent_events
                            for report in done_reports
                            if report.new_parent_events
                        ]
                    )
                )
                executor_events.sort(key=lambda event: event.timestamp)
                self.add_to_event_log(executor_events)
            if self.focused_subtask and self.focused_subtask.closed:
                self.unfocus_subtask()
            action_decision = self.choose_action()
            if action_decision.additional_thoughts:
                self.add_thought(action_decision.additional_thoughts)
            action_result = self.act(action_decision)
            if action_result.new_events:
                self.add_to_event_log(action_result.new_events)
            if action_result.pause_execution:
                break
        task_completed = action_result.task_completed
        assert (
            (last_event := self.event_log.last_event)
            and isinstance(last_event.data, Message)
            and last_event.data.sender == self.id
        ), f"Execution report creation: last event is expected to be a message from the orchestrator, but is: {last_event}"
        return ExecutionReport(
            reply=last_event.data.content,
            task_completed=task_completed,
        )

    @classmethod
    def load(
        cls,
        blueprint_location: Path,
        task: Task,
        files_parent_dir: Path,
        delegator: "Delegator",
    ) -> Self:
        """Deserialize an orchestrator from a YAML file."""
        blueprint_data = DEFAULT_YAML.load(blueprint_location)
        return cls(
            blueprint=OrchestratorBlueprint(**blueprint_data),
            task=task,
            files_parent_dir=files_parent_dir,
            delegator=delegator,
        )
